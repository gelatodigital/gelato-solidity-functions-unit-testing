{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Automate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.14;\r\n\r\nimport {\r\n    EnumerableSet\r\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport {Gelatofied} from \"./vendor/gelato/Gelatofied.sol\";\r\nimport {GelatoBytes} from \"./vendor/gelato/GelatoBytes.sol\";\r\nimport {Proxied} from \"./vendor/proxy/EIP173/Proxied.sol\";\r\nimport {AutomateStorage} from \"./AutomateStorage.sol\";\r\nimport {LibDataTypes} from \"./libraries/LibDataTypes.sol\";\r\nimport {LibEvents} from \"./libraries/LibEvents.sol\";\r\nimport {LibTaskId} from \"./libraries/LibTaskId.sol\";\r\nimport {LibTaskModule} from \"./libraries/LibTaskModule.sol\";\r\nimport {IAutomate} from \"./interfaces/IAutomate.sol\";\r\n\r\n/**\r\n * @notice Automate enables everyone to have Gelato monitor and execute transactions.\r\n * @notice ExecAddress refers to the contract that has the function which Gelato will call.\r\n * @notice Modules allow users to customise conditions and specifications when creating a task.\r\n */\r\n//solhint-disable function-max-lines\r\n//solhint-disable no-empty-blocks\r\ncontract Automate is Gelatofied, Proxied, AutomateStorage, IAutomate {\r\n    using GelatoBytes for bytes;\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n\r\n    // solhint-disable const-name-snakecase\r\n    string public constant version = \"6\";\r\n\r\n    constructor(address payable _gelato) Gelatofied(_gelato) {}\r\n\r\n    ///@inheritdoc IAutomate\r\n    function createTask(\r\n        address _execAddress,\r\n        bytes calldata _execDataOrSelector,\r\n        LibDataTypes.ModuleData calldata _moduleData,\r\n        address _feeToken\r\n    ) external override returns (bytes32 taskId) {\r\n        address taskCreator;\r\n\r\n        (taskCreator, _execAddress) = LibTaskModule.preCreateTask(\r\n            msg.sender,\r\n            _execAddress,\r\n            taskModuleAddresses\r\n        );\r\n\r\n        taskId = _createTask(\r\n            taskCreator,\r\n            _execAddress,\r\n            _execDataOrSelector,\r\n            _moduleData,\r\n            _feeToken\r\n        );\r\n    }\r\n\r\n    ///@inheritdoc IAutomate\r\n    function cancelTask(bytes32 _taskId) external {\r\n        address _taskCreator = LibTaskModule.preCancelTask(\r\n            _taskId,\r\n            msg.sender,\r\n            taskModuleAddresses\r\n        );\r\n\r\n        _cancelTask(_taskCreator, _taskId);\r\n    }\r\n\r\n    ///@inheritdoc IAutomate\r\n    function exec(\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes memory _execData,\r\n        LibDataTypes.ModuleData calldata _moduleData,\r\n        uint256 _txFee,\r\n        address _feeToken,\r\n        bool _revertOnFailure\r\n    ) external onlyGelato {\r\n        bytes32 taskId = LibTaskId.getTaskId(\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execData.memorySliceSelector(),\r\n            _moduleData,\r\n            _feeToken\r\n        );\r\n\r\n        require(\r\n            _createdTasks[_taskCreator].contains(taskId),\r\n            \"Automate.exec: Task not found\"\r\n        );\r\n\r\n        fee = _txFee;\r\n        feeToken = _feeToken;\r\n\r\n        bool success = LibTaskModule.onExecTask(\r\n            taskId,\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execData,\r\n            _moduleData.modules,\r\n            _revertOnFailure,\r\n            taskModuleAddresses\r\n        );\r\n\r\n        delete fee;\r\n        delete feeToken;\r\n\r\n        emit LibEvents.ExecSuccess(\r\n            _txFee,\r\n            _feeToken,\r\n            _execAddress,\r\n            _execData,\r\n            taskId,\r\n            success\r\n        );\r\n    }\r\n\r\n    ///@inheritdoc IAutomate\r\n    function exec1Balance(\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes memory _execData,\r\n        LibDataTypes.ModuleData calldata _moduleData,\r\n        Gelato1BalanceParam calldata _oneBalanceParam,\r\n        bool _revertOnFailure\r\n    ) external onlyGelato {\r\n        bytes32 taskId = LibTaskId.getTaskId(\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execData.memorySliceSelector(),\r\n            _moduleData,\r\n            address(0)\r\n        );\r\n\r\n        require(\r\n            _createdTasks[_taskCreator].contains(taskId),\r\n            \"Automate.exec: Task not found\"\r\n        );\r\n\r\n        bool success = LibTaskModule.onExecTask(\r\n            taskId,\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execData,\r\n            _moduleData.modules,\r\n            _revertOnFailure,\r\n            taskModuleAddresses\r\n        );\r\n\r\n        emit LibEvents.ExecSuccess(\r\n            0,\r\n            address(0),\r\n            _execAddress,\r\n            _execData,\r\n            taskId,\r\n            success\r\n        );\r\n\r\n        emit LogUseGelato1Balance(\r\n            _oneBalanceParam.sponsor,\r\n            _execAddress,\r\n            _oneBalanceParam.feeToken,\r\n            _oneBalanceParam.oneBalanceChainId,\r\n            _oneBalanceParam.nativeToFeeTokenXRateNumerator,\r\n            _oneBalanceParam.nativeToFeeTokenXRateDenominator,\r\n            _oneBalanceParam.correlationId\r\n        );\r\n    }\r\n\r\n    ///@inheritdoc IAutomate\r\n    function setModule(\r\n        LibDataTypes.Module[] calldata _modules,\r\n        address[] calldata _moduleAddresses\r\n    ) external onlyProxyAdmin {\r\n        uint256 length = _modules.length;\r\n        for (uint256 i; i < length; i++) {\r\n            taskModuleAddresses[_modules[i]] = _moduleAddresses[i];\r\n        }\r\n    }\r\n\r\n    ///@inheritdoc IAutomate\r\n    function getFeeDetails() external view returns (uint256, address) {\r\n        return (fee, feeToken);\r\n    }\r\n\r\n    ///@inheritdoc IAutomate\r\n    function getTaskIdsByUser(address _taskCreator)\r\n        external\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        bytes32[] memory taskIds = _createdTasks[_taskCreator].values();\r\n\r\n        return taskIds;\r\n    }\r\n\r\n    ///@inheritdoc IAutomate\r\n    function getTaskId(\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes4 execSelector,\r\n        LibDataTypes.ModuleData memory moduleData,\r\n        address feeToken\r\n    ) external pure returns (bytes32 taskId) {\r\n        taskId = LibTaskId.getTaskId(\r\n            taskCreator,\r\n            execAddress,\r\n            execSelector,\r\n            moduleData,\r\n            feeToken\r\n        );\r\n    }\r\n\r\n    function _createTask(\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes memory _execDataOrSelector,\r\n        LibDataTypes.ModuleData memory _moduleData,\r\n        address _feeToken\r\n    ) private returns (bytes32 taskId) {\r\n        taskId = LibTaskId.getTaskId(\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execDataOrSelector.memorySliceSelector(),\r\n            _moduleData,\r\n            _feeToken\r\n        );\r\n\r\n        require(\r\n            !_createdTasks[_taskCreator].contains(taskId),\r\n            \"Automate.createTask: Duplicate task\"\r\n        );\r\n\r\n        LibTaskModule.onCreateTask(\r\n            taskId,\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execDataOrSelector,\r\n            _moduleData,\r\n            taskModuleAddresses\r\n        );\r\n\r\n        _createdTasks[_taskCreator].add(taskId);\r\n\r\n        emit LibEvents.TaskCreated(\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execDataOrSelector,\r\n            _moduleData,\r\n            _feeToken,\r\n            taskId\r\n        );\r\n    }\r\n\r\n    function _cancelTask(address _taskCreator, bytes32 _taskId) private {\r\n        require(\r\n            _createdTasks[_taskCreator].contains(_taskId),\r\n            \"Automate.cancelTask: Task not found\"\r\n        );\r\n\r\n        _createdTasks[_taskCreator].remove(_taskId);\r\n\r\n        emit LibEvents.TaskCancelled(_taskId, _taskCreator);\r\n    }\r\n}\r\n"
    },
    "contracts/AutomateStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\nimport {\r\n    EnumerableSet\r\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport {LibDataTypes} from \"./libraries/LibDataTypes.sol\";\r\n\r\n/**\r\n * @notice Storage layout of Automate smart contract.\r\n */\r\n// solhint-disable max-states-count\r\nabstract contract AutomateStorage {\r\n    mapping(bytes32 => address) public taskCreator; ///@dev Deprecated\r\n    mapping(bytes32 => address) public execAddresses; ///@dev Deprecated\r\n    mapping(address => EnumerableSet.Bytes32Set) internal _createdTasks;\r\n\r\n    uint256 public fee;\r\n    address public feeToken;\r\n\r\n    ///@dev Appended State\r\n    mapping(bytes32 => LibDataTypes.Time) public timedTask; ///@dev Deprecated\r\n    mapping(LibDataTypes.Module => address) public taskModuleAddresses;\r\n    mapping(bytes32 => uint256) public nonce1Balance; ///@dev Deprecated\r\n}\r\n"
    },
    "contracts/functions/FExec.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\nimport {GelatoBytes} from \"../vendor/gelato/GelatoBytes.sol\";\r\n\r\n// solhint-disable private-vars-leading-underscore\r\n// solhint-disable func-visibility\r\n\r\nfunction _call(\r\n    address _add,\r\n    bytes memory _data,\r\n    uint256 _value,\r\n    bool _revertOnFailure,\r\n    string memory _tracingInfo\r\n) returns (bool success, bytes memory returnData) {\r\n    (success, returnData) = _add.call{value: _value}(_data);\r\n\r\n    if (!success && _revertOnFailure)\r\n        GelatoBytes.revertWithError(returnData, _tracingInfo);\r\n}\r\n\r\nfunction _delegateCall(\r\n    address _add,\r\n    bytes memory _data,\r\n    string memory _tracingInfo\r\n) returns (bool success, bytes memory returnData) {\r\n    (success, returnData) = _add.delegatecall(_data);\r\n\r\n    if (!success) GelatoBytes.revertWithError(returnData, _tracingInfo);\r\n}\r\n"
    },
    "contracts/functions/FUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {\r\n    SafeERC20,\r\n    IERC20\r\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\naddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n// solhint-disable private-vars-leading-underscore\r\n// solhint-disable func-visibility\r\nfunction _transfer(\r\n    address payable _to,\r\n    address _paymentToken,\r\n    uint256 _amount\r\n) {\r\n    if (_paymentToken == ETH) {\r\n        (bool success, ) = _to.call{value: _amount}(\"\");\r\n        require(success, \"_transfer: ETH transfer failed\");\r\n    } else {\r\n        SafeERC20.safeTransfer(IERC20(_paymentToken), _to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/AutomateReady.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./Types.sol\";\r\n\r\n/**\r\n * @dev Inherit this contract to allow your smart contract to\r\n * - Make synchronous fee payments.\r\n * - Have call restrictions for functions to be automated.\r\n */\r\n// solhint-disable private-vars-leading-underscore\r\nabstract contract AutomateReady {\r\n    IAutomate public immutable automate;\r\n    address public immutable dedicatedMsgSender;\r\n    address private immutable feeCollector;\r\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    /**\r\n     * @dev\r\n     * Only tasks created by _taskCreator defined in constructor can call\r\n     * the functions with this modifier.\r\n     */\r\n    modifier onlyDedicatedMsgSender() {\r\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev\r\n     * _taskCreator is the address which will create tasks for this contract.\r\n     */\r\n    constructor(address _automate, address _taskCreator) {\r\n        automate = IAutomate(_automate);\r\n        IGelato gelato = IGelato(IAutomate(_automate).gelato());\r\n\r\n        feeCollector = gelato.feeCollector();\r\n\r\n        address proxyModuleAddress = IAutomate(_automate).taskModuleAddresses(\r\n            Module.PROXY\r\n        );\r\n\r\n        address opsProxyFactoryAddress = IProxyModule(proxyModuleAddress)\r\n            .opsProxyFactory();\r\n\r\n        (dedicatedMsgSender, ) = IOpsProxyFactory(opsProxyFactoryAddress)\r\n            .getProxyOf(_taskCreator);\r\n    }\r\n\r\n    /**\r\n     * @dev\r\n     * Transfers fee to gelato for synchronous fee payments.\r\n     *\r\n     * _fee & _feeToken should be queried from IAutomate.getFeeDetails()\r\n     */\r\n    function _transfer(uint256 _fee, address _feeToken) internal {\r\n        if (_feeToken == ETH) {\r\n            (bool success, ) = feeCollector.call{value: _fee}(\"\");\r\n            require(success, \"_transfer: ETH transfer failed\");\r\n        } else {\r\n            SafeERC20.safeTransfer(IERC20(_feeToken), feeCollector, _fee);\r\n        }\r\n    }\r\n\r\n    function _getFeeDetails()\r\n        internal\r\n        view\r\n        returns (uint256 fee, address feeToken)\r\n    {\r\n        (fee, feeToken) = automate.getFeeDetails();\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/AutomateReadyUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./Types.sol\";\r\nimport {\r\n    Initializable\r\n} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Inherit this contract to allow your upgradeable smart contract to\r\n * - Make synchronous fee payments.\r\n * - Have call restrictions for functions to be automated.\r\n */\r\n//solhint-disable func-name-mixedcase\r\n// solhint-disable private-vars-leading-underscore\r\nabstract contract AutomateReadyUpgradeable is Initializable {\r\n    IAutomate public immutable automate;\r\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address internal feeCollector;\r\n    address public dedicatedMsgSender;\r\n\r\n    /**\r\n     * @dev\r\n     * Only tasks created by _taskCreator defined in constructor can call\r\n     * the functions with this modifier.\r\n     */\r\n    modifier onlyDedicatedMsgSender() {\r\n        require(msg.sender == dedicatedMsgSender, \"Only dedicated msg.sender\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _automate) {\r\n        automate = IAutomate(_automate);\r\n    }\r\n\r\n    /**\r\n     * @dev\r\n     * _taskCreator is the address which will create tasks for this contract.\r\n     */\r\n    function __AutomateReady_init(address _taskCreator)\r\n        internal\r\n        onlyInitializing\r\n    {\r\n        IGelato gelato = IGelato(automate.gelato());\r\n\r\n        feeCollector = gelato.feeCollector();\r\n\r\n        address proxyModuleAddress = IAutomate(automate).taskModuleAddresses(\r\n            Module.PROXY\r\n        );\r\n\r\n        address opsProxyFactoryAddress = IProxyModule(proxyModuleAddress)\r\n            .opsProxyFactory();\r\n\r\n        (dedicatedMsgSender, ) = IOpsProxyFactory(opsProxyFactoryAddress)\r\n            .getProxyOf(_taskCreator);\r\n    }\r\n\r\n    /**\r\n     * @dev\r\n     * Transfers fee to gelato for synchronous fee payments.\r\n     *\r\n     * _fee & _feeToken should be queried from IAutomate.getFeeDetails()\r\n     */\r\n    function _transfer(uint256 _fee, address _feeToken) internal {\r\n        if (_feeToken == ETH) {\r\n            (bool success, ) = feeCollector.call{value: _fee}(\"\");\r\n            require(success, \"_transfer: ETH transfer failed\");\r\n        } else {\r\n            SafeERC20.safeTransfer(IERC20(_feeToken), feeCollector, _fee);\r\n        }\r\n    }\r\n\r\n    function _getFeeDetails()\r\n        internal\r\n        view\r\n        returns (uint256 fee, address feeToken)\r\n    {\r\n        (fee, feeToken) = automate.getFeeDetails();\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/AutomateTaskCreator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./AutomateReady.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @dev Inherit this contract to allow your smart contract\r\n * to be a task creator and create tasks.\r\n */\r\n//solhint-disable const-name-snakecase\r\n//solhint-disable no-empty-blocks\r\nabstract contract AutomateTaskCreator is AutomateReady {\r\n    using SafeERC20 for IERC20;\r\n\r\n    IGelato1Balance public constant gelato1Balance =\r\n        IGelato1Balance(0x7506C12a824d73D9b08564d5Afc22c949434755e);\r\n\r\n    constructor(address _automate) AutomateReady(_automate, address(this)) {}\r\n\r\n    function _depositFunds1Balance(\r\n        uint256 _amount,\r\n        address _token,\r\n        address _sponsor\r\n    ) internal {\r\n        if (_token == ETH) {\r\n            ///@dev Only deposit ETH on goerli for now.\r\n            require(block.chainid == 5, \"Only deposit ETH on goerli\");\r\n            gelato1Balance.depositNative{value: _amount}(_sponsor);\r\n        } else {\r\n            ///@dev Only deposit USDC on polygon for now.\r\n            require(\r\n                block.chainid == 137 &&\r\n                    _token ==\r\n                    address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174),\r\n                \"Only deposit USDC on polygon\"\r\n            );\r\n            IERC20(_token).approve(address(gelato1Balance), _amount);\r\n            gelato1Balance.depositToken(_sponsor, _token, _amount);\r\n        }\r\n    }\r\n\r\n    function _createTask(\r\n        address _execAddress,\r\n        bytes memory _execDataOrSelector,\r\n        ModuleData memory _moduleData,\r\n        address _feeToken\r\n    ) internal returns (bytes32) {\r\n        return\r\n            automate.createTask(\r\n                _execAddress,\r\n                _execDataOrSelector,\r\n                _moduleData,\r\n                _feeToken\r\n            );\r\n    }\r\n\r\n    function _cancelTask(bytes32 _taskId) internal {\r\n        automate.cancelTask(_taskId);\r\n    }\r\n\r\n    function _resolverModuleArg(\r\n        address _resolverAddress,\r\n        bytes memory _resolverData\r\n    ) internal pure returns (bytes memory) {\r\n        return abi.encode(_resolverAddress, _resolverData);\r\n    }\r\n\r\n    function _proxyModuleArg() internal pure returns (bytes memory) {\r\n        return bytes(\"\");\r\n    }\r\n\r\n    function _singleExecModuleArg() internal pure returns (bytes memory) {\r\n        return bytes(\"\");\r\n    }\r\n\r\n    function _web3FunctionModuleArg(\r\n        string memory _web3FunctionHash,\r\n        bytes memory _web3FunctionArgsHex\r\n    ) internal pure returns (bytes memory) {\r\n        return abi.encode(_web3FunctionHash, _web3FunctionArgsHex);\r\n    }\r\n\r\n    function _timeTriggerModuleArg(uint128 _start, uint128 _interval)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory triggerConfig = abi.encode(_start, _interval);\r\n\r\n        return abi.encode(TriggerType.TIME, triggerConfig);\r\n    }\r\n\r\n    function _cronTriggerModuleArg(string memory _expression)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory triggerConfig = abi.encode(_expression);\r\n\r\n        return abi.encode(TriggerType.CRON, triggerConfig);\r\n    }\r\n\r\n    function _eventTriggerModuleArg(\r\n        address _address,\r\n        bytes32[][] memory _topics,\r\n        uint256 _blockConfirmations\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory triggerConfig = abi.encode(\r\n            _address,\r\n            _topics,\r\n            _blockConfirmations\r\n        );\r\n\r\n        return abi.encode(TriggerType.EVENT, triggerConfig);\r\n    }\r\n\r\n    function _blockTriggerModuleArg() internal pure returns (bytes memory) {\r\n        bytes memory triggerConfig = abi.encode(bytes(\"\"));\r\n\r\n        return abi.encode(TriggerType.BLOCK, triggerConfig);\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/AutomateTaskCreatorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./AutomateReadyUpgradeable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @dev Inherit this contract to allow your upgradeable smart contract\r\n * to be a task creator and create tasks.\r\n */\r\n//solhint-disable func-name-mixedcase\r\n//solhint-disable const-name-snakecase\r\n//solhint-disable no-empty-blocks\r\nabstract contract AutomateTaskCreatorUpgradeable is AutomateReadyUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    IGelato1Balance public constant gelato1Balance =\r\n        IGelato1Balance(0x7506C12a824d73D9b08564d5Afc22c949434755e);\r\n\r\n    constructor(address _automate) AutomateReadyUpgradeable(_automate) {}\r\n\r\n    function __AutomateTaskCreator_init() internal onlyInitializing {\r\n        __AutomateReady_init(address(this));\r\n    }\r\n\r\n    function _depositFunds1Balance(\r\n        uint256 _amount,\r\n        address _token,\r\n        address _sponsor\r\n    ) internal {\r\n        if (_token == ETH) {\r\n            ///@dev Only deposit ETH on goerli for now.\r\n            require(block.chainid == 5, \"Only deposit ETH on goerli\");\r\n            gelato1Balance.depositNative{value: _amount}(_sponsor);\r\n        } else {\r\n            ///@dev Only deposit USDC on polygon for now.\r\n            require(\r\n                block.chainid == 137 &&\r\n                    _token ==\r\n                    address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174),\r\n                \"Only deposit USDC on polygon\"\r\n            );\r\n            IERC20(_token).approve(address(gelato1Balance), _amount);\r\n            gelato1Balance.depositToken(_sponsor, _token, _amount);\r\n        }\r\n    }\r\n\r\n    function _createTask(\r\n        address _execAddress,\r\n        bytes memory _execDataOrSelector,\r\n        ModuleData memory _moduleData,\r\n        address _feeToken\r\n    ) internal returns (bytes32) {\r\n        return\r\n            automate.createTask(\r\n                _execAddress,\r\n                _execDataOrSelector,\r\n                _moduleData,\r\n                _feeToken\r\n            );\r\n    }\r\n\r\n    function _cancelTask(bytes32 _taskId) internal {\r\n        automate.cancelTask(_taskId);\r\n    }\r\n\r\n    function _resolverModuleArg(\r\n        address _resolverAddress,\r\n        bytes memory _resolverData\r\n    ) internal pure returns (bytes memory) {\r\n        return abi.encode(_resolverAddress, _resolverData);\r\n    }\r\n\r\n    function _proxyModuleArg() internal pure returns (bytes memory) {\r\n        return bytes(\"\");\r\n    }\r\n\r\n    function _singleExecModuleArg() internal pure returns (bytes memory) {\r\n        return bytes(\"\");\r\n    }\r\n\r\n    function _web3FunctionModuleArg(\r\n        string memory _web3FunctionHash,\r\n        bytes memory _web3FunctionArgsHex\r\n    ) internal pure returns (bytes memory) {\r\n        return abi.encode(_web3FunctionHash, _web3FunctionArgsHex);\r\n    }\r\n\r\n    function _timeTriggerModuleArg(uint128 _start, uint128 _interval)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory triggerConfig = abi.encode(_start, _interval);\r\n\r\n        return abi.encode(TriggerType.TIME, triggerConfig);\r\n    }\r\n\r\n    function _cronTriggerModuleArg(string memory _expression)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory triggerConfig = abi.encode(_expression);\r\n\r\n        return abi.encode(TriggerType.CRON, triggerConfig);\r\n    }\r\n\r\n    function _blockTriggerModuleArg() internal pure returns (bytes memory) {\r\n        bytes memory triggerConfig = abi.encode(bytes(\"\"));\r\n\r\n        return abi.encode(TriggerType.BLOCK, triggerConfig);\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/contractCreator/withoutTreasury/CounterResolverTaskCreatorWT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../../AutomateTaskCreator.sol\";\r\n\r\n/**\r\n * @dev\r\n * Example contract that creates a resolver task.\r\n */\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\ncontract CounterResolverTaskCreatorWT is AutomateTaskCreator {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n    bytes32 public taskId;\r\n    uint256 public constant MAX_COUNT = 5;\r\n    uint256 public constant INTERVAL = 3 minutes;\r\n\r\n    event CounterTaskCreated(bytes32 taskId);\r\n\r\n    constructor(address payable _automate) AutomateTaskCreator(_automate) {}\r\n\r\n    receive() external payable {}\r\n\r\n    function createTask() external payable {\r\n        require(taskId == bytes32(\"\"), \"Already started task\");\r\n\r\n        ModuleData memory moduleData = ModuleData({\r\n            modules: new Module[](2),\r\n            args: new bytes[](2)\r\n        });\r\n\r\n        moduleData.modules[0] = Module.RESOLVER;\r\n        moduleData.modules[1] = Module.PROXY;\r\n\r\n        moduleData.args[0] = _resolverModuleArg(\r\n            address(this),\r\n            abi.encodeCall(this.checker, ())\r\n        );\r\n        moduleData.args[1] = _proxyModuleArg();\r\n\r\n        bytes32 id = _createTask(\r\n            address(this),\r\n            abi.encode(this.increaseCount.selector),\r\n            moduleData,\r\n            ETH\r\n        );\r\n\r\n        taskId = id;\r\n        emit CounterTaskCreated(id);\r\n    }\r\n\r\n    function increaseCount(uint256 _amount) external onlyDedicatedMsgSender {\r\n        uint256 newCount = count + _amount;\r\n\r\n        if (newCount >= MAX_COUNT) {\r\n            _cancelTask(taskId);\r\n            count = 0;\r\n        } else {\r\n            count += _amount;\r\n            lastExecuted = block.timestamp;\r\n        }\r\n\r\n        (uint256 fee, address feeToken) = _getFeeDetails();\r\n\r\n        _transfer(fee, feeToken);\r\n    }\r\n\r\n    function checker()\r\n        external\r\n        view\r\n        returns (bool canExec, bytes memory execPayload)\r\n    {\r\n        canExec = (block.timestamp - lastExecuted) >= INTERVAL;\r\n\r\n        execPayload = abi.encodeCall(this.increaseCount, (1));\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/contractCreator/withoutTreasury/CounterSingleExecTaskCreatorWT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../../AutomateTaskCreator.sol\";\r\n\r\n/**\r\n * @dev\r\n * Example contract that creates a single exec task.\r\n */\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\ncontract CounterSingleExecTaskCreatorWT is AutomateTaskCreator {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n    bytes32 public taskId;\r\n    uint256 public constant MAX_COUNT = 5;\r\n    uint256 public constant INTERVAL = 3 minutes;\r\n\r\n    event CounterTaskCreated(bytes32 taskId);\r\n\r\n    constructor(address payable _automate) AutomateTaskCreator(_automate) {}\r\n\r\n    receive() external payable {}\r\n\r\n    function createTask() external payable {\r\n        require(taskId == bytes32(\"\"), \"Already started task\");\r\n\r\n        bytes memory execData = abi.encodeCall(this.increaseCount, (1));\r\n\r\n        ModuleData memory moduleData = ModuleData({\r\n            modules: new Module[](2),\r\n            args: new bytes[](2)\r\n        });\r\n\r\n        moduleData.modules[0] = Module.PROXY;\r\n        moduleData.modules[1] = Module.SINGLE_EXEC;\r\n\r\n        moduleData.args[0] = _proxyModuleArg();\r\n        moduleData.args[1] = _singleExecModuleArg();\r\n\r\n        bytes32 id = _createTask(address(this), execData, moduleData, ETH);\r\n\r\n        taskId = id;\r\n        emit CounterTaskCreated(id);\r\n    }\r\n\r\n    function increaseCount(uint256 _amount) external onlyDedicatedMsgSender {\r\n        count += _amount;\r\n        taskId = bytes32(\"\");\r\n\r\n        (uint256 fee, address feeToken) = _getFeeDetails();\r\n\r\n        _transfer(fee, feeToken);\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/contractCreator/withoutTreasury/CounterTriggerTaskCreatorWT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../../AutomateTaskCreator.sol\";\r\n\r\n/**\r\n * @dev\r\n * Example contract that creates a trigger task.\r\n */\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\ncontract CounterTriggerTaskCreatorWT is AutomateTaskCreator {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n    bytes32 public taskId;\r\n    uint256 public constant MAX_COUNT = 5;\r\n    uint128 public constant INTERVAL = 3 minutes;\r\n\r\n    event CounterTaskCreated(bytes32 taskId);\r\n\r\n    constructor(address payable _automate) AutomateTaskCreator(_automate) {}\r\n\r\n    receive() external payable {}\r\n\r\n    function createTask() external payable {\r\n        require(taskId == bytes32(\"\"), \"Already started task\");\r\n\r\n        bytes memory execData = abi.encodeCall(this.increaseCount, (1));\r\n\r\n        ModuleData memory moduleData = ModuleData({\r\n            modules: new Module[](2),\r\n            args: new bytes[](2)\r\n        });\r\n        moduleData.modules[0] = Module.TRIGGER;\r\n        moduleData.modules[1] = Module.PROXY;\r\n\r\n        moduleData.args[0] = _timeTriggerModuleArg(\r\n            uint128(block.timestamp),\r\n            INTERVAL\r\n        );\r\n        moduleData.args[1] = _proxyModuleArg();\r\n\r\n        bytes32 id = _createTask(address(this), execData, moduleData, ETH);\r\n\r\n        taskId = id;\r\n        emit CounterTaskCreated(id);\r\n    }\r\n\r\n    function increaseCount(uint256 _amount) external onlyDedicatedMsgSender {\r\n        uint256 newCount = count + _amount;\r\n\r\n        if (newCount >= MAX_COUNT) {\r\n            _cancelTask(taskId);\r\n            count = 0;\r\n        } else {\r\n            count += _amount;\r\n            lastExecuted = block.timestamp;\r\n        }\r\n\r\n        (uint256 fee, address feeToken) = _getFeeDetails();\r\n\r\n        _transfer(fee, feeToken);\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/contractCreator/withTreasury/CounterResolverTaskCreator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../../AutomateTaskCreator.sol\";\r\n\r\n/**\r\n * @dev\r\n * Example contract that creates a resolver task.\r\n */\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\ncontract CounterResolverTaskCreator is AutomateTaskCreator {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n    bytes32 public taskId;\r\n    uint256 public constant MAX_COUNT = 5;\r\n    uint256 public constant INTERVAL = 3 minutes;\r\n\r\n    event CounterTaskCreated(bytes32 taskId);\r\n\r\n    constructor(address _automate) AutomateTaskCreator(_automate) {}\r\n\r\n    function createTask() external {\r\n        require(taskId == bytes32(\"\"), \"Already started task\");\r\n\r\n        ModuleData memory moduleData = ModuleData({\r\n            modules: new Module[](2),\r\n            args: new bytes[](2)\r\n        });\r\n\r\n        moduleData.modules[0] = Module.RESOLVER;\r\n        moduleData.modules[1] = Module.PROXY;\r\n\r\n        moduleData.args[0] = _resolverModuleArg(\r\n            address(this),\r\n            abi.encodeCall(this.checker, ())\r\n        );\r\n        moduleData.args[1] = _proxyModuleArg();\r\n\r\n        bytes32 id = _createTask(\r\n            address(this),\r\n            abi.encode(this.increaseCount.selector),\r\n            moduleData,\r\n            address(0)\r\n        );\r\n\r\n        taskId = id;\r\n        emit CounterTaskCreated(id);\r\n    }\r\n\r\n    function increaseCount(uint256 _amount) external onlyDedicatedMsgSender {\r\n        uint256 newCount = count + _amount;\r\n\r\n        if (newCount >= MAX_COUNT) {\r\n            _cancelTask(taskId);\r\n            count = 0;\r\n        } else {\r\n            count += _amount;\r\n            lastExecuted = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function checker()\r\n        external\r\n        view\r\n        returns (bool canExec, bytes memory execPayload)\r\n    {\r\n        canExec = (block.timestamp - lastExecuted) >= INTERVAL;\r\n\r\n        execPayload = abi.encodeCall(this.increaseCount, (1));\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/contractCreator/withTreasury/CounterSingleExecTaskCreator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../../AutomateTaskCreator.sol\";\r\n\r\n/**\r\n * @dev\r\n * Example contract that creates a single exec task.\r\n */\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\ncontract CounterSingleExecTaskCreator is AutomateTaskCreator {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n    bytes32 public taskId;\r\n    uint256 public constant MAX_COUNT = 5;\r\n    uint256 public constant INTERVAL = 3 minutes;\r\n\r\n    event CounterTaskCreated(bytes32 taskId);\r\n\r\n    constructor(address _automate) AutomateTaskCreator(_automate) {}\r\n\r\n    function createTask() external {\r\n        require(taskId == bytes32(\"\"), \"Already started task\");\r\n\r\n        bytes memory execData = abi.encodeCall(this.increaseCount, (1));\r\n\r\n        ModuleData memory moduleData = ModuleData({\r\n            modules: new Module[](2),\r\n            args: new bytes[](2)\r\n        });\r\n        moduleData.modules[0] = Module.PROXY;\r\n        moduleData.modules[1] = Module.SINGLE_EXEC;\r\n\r\n        moduleData.args[0] = _proxyModuleArg();\r\n        moduleData.args[1] = _singleExecModuleArg();\r\n\r\n        bytes32 id = _createTask(\r\n            address(this),\r\n            execData,\r\n            moduleData,\r\n            address(0)\r\n        );\r\n\r\n        taskId = id;\r\n        emit CounterTaskCreated(id);\r\n    }\r\n\r\n    function increaseCount(uint256 _amount) external onlyDedicatedMsgSender {\r\n        count += _amount;\r\n        taskId = bytes32(\"\");\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/contractCreator/withTreasury/CounterTriggerTaskCreator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../../AutomateTaskCreator.sol\";\r\n\r\n/**\r\n * @dev\r\n * Example contract that creates a time task.\r\n */\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\ncontract CounterTriggerTaskCreator is AutomateTaskCreator {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n    bytes32 public taskId;\r\n    uint256 public constant MAX_COUNT = 5;\r\n    uint128 public constant INTERVAL = 3 minutes;\r\n\r\n    event CounterTaskCreated(bytes32 taskId);\r\n\r\n    constructor(address _automate) AutomateTaskCreator(_automate) {}\r\n\r\n    function createTask() external {\r\n        require(taskId == bytes32(\"\"), \"Already started task\");\r\n\r\n        bytes memory execData = abi.encodeCall(this.increaseCount, (1));\r\n\r\n        ModuleData memory moduleData = ModuleData({\r\n            modules: new Module[](2),\r\n            args: new bytes[](2)\r\n        });\r\n        moduleData.modules[0] = Module.TRIGGER;\r\n        moduleData.modules[1] = Module.PROXY;\r\n\r\n        moduleData.args[0] = _timeTriggerModuleArg(\r\n            uint128(block.timestamp),\r\n            INTERVAL\r\n        );\r\n        moduleData.args[1] = _proxyModuleArg();\r\n\r\n        bytes32 id = _createTask(\r\n            address(this),\r\n            execData,\r\n            moduleData,\r\n            address(0)\r\n        );\r\n\r\n        taskId = id;\r\n        emit CounterTaskCreated(id);\r\n    }\r\n\r\n    function increaseCount(uint256 _amount) external onlyDedicatedMsgSender {\r\n        uint256 newCount = count + _amount;\r\n\r\n        if (newCount >= MAX_COUNT) {\r\n            _cancelTask(taskId);\r\n            count = 0;\r\n        } else {\r\n            count += _amount;\r\n            lastExecuted = block.timestamp;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/contractCreator/withTreasury/CounterWeb3Function.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\nimport \"../../../AutomateTaskCreator.sol\";\r\n\r\n//solhint-disable no-empty-blocks\r\n//solhint-disable not-rely-on-time\r\ncontract CounterWeb3Function is AutomateTaskCreator {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n    bytes32 public taskId;\r\n    uint256 public constant MAX_COUNT = 5;\r\n    uint256 public constant INTERVAL = 3 minutes;\r\n\r\n    event CounterTaskCreated(bytes32 taskId);\r\n\r\n    constructor(address _automate) AutomateTaskCreator(_automate) {}\r\n\r\n    function createTask(\r\n        string memory _web3FunctionHash,\r\n        bytes calldata _web3FunctionArgsHex\r\n    ) external {\r\n        require(taskId == bytes32(\"\"), \"Already started task\");\r\n\r\n        bytes memory execData = abi.encodeCall(this.increaseCount, (1));\r\n\r\n        ModuleData memory moduleData = ModuleData({\r\n            modules: new Module[](2),\r\n            args: new bytes[](2)\r\n        });\r\n        moduleData.modules[0] = Module.PROXY;\r\n        moduleData.modules[1] = Module.WEB3_FUNCTION;\r\n\r\n        moduleData.args[0] = _proxyModuleArg();\r\n        moduleData.args[1] = _web3FunctionModuleArg(\r\n            _web3FunctionHash,\r\n            _web3FunctionArgsHex\r\n        );\r\n\r\n        bytes32 id = _createTask(\r\n            address(this),\r\n            execData,\r\n            moduleData,\r\n            address(0)\r\n        );\r\n\r\n        taskId = id;\r\n        emit CounterTaskCreated(id);\r\n    }\r\n\r\n    function cancelTask() external {\r\n        require(taskId != bytes32(\"\"), \"Task not started\");\r\n        _cancelTask(taskId);\r\n    }\r\n\r\n    function increaseCount(uint256 _amount) external onlyDedicatedMsgSender {\r\n        uint256 newCount = count + _amount;\r\n\r\n        if (newCount >= MAX_COUNT) {\r\n            _cancelTask(taskId);\r\n            count = 0;\r\n        } else {\r\n            count += _amount;\r\n            lastExecuted = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function depositFunds(uint256 _amount, address _token) external payable {\r\n        _depositFunds1Balance(_amount, _token, address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/userCreator/withoutTreasury/CounterResolverWT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICounter {\r\n    function increaseCount(uint256 amount) external;\r\n\r\n    function lastExecuted() external view returns (uint256);\r\n}\r\n\r\n// solhint-disable not-rely-on-time\r\ncontract CounterResolverWT {\r\n    ICounter public immutable counter;\r\n\r\n    constructor(ICounter _counter) {\r\n        counter = _counter;\r\n    }\r\n\r\n    function checker()\r\n        external\r\n        view\r\n        returns (bool canExec, bytes memory execPayload)\r\n    {\r\n        uint256 lastExecuted = counter.lastExecuted();\r\n\r\n        canExec = (block.timestamp - lastExecuted) > 180;\r\n\r\n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/userCreator/withoutTreasury/CounterWT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport {AutomateReady} from \"../../../AutomateReady.sol\";\r\n\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\ncontract CounterWT is AutomateReady {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n\r\n    constructor(address _automate, address _taskCreator)\r\n        AutomateReady(_automate, _taskCreator)\r\n    {}\r\n\r\n    receive() external payable {}\r\n\r\n    function increaseCount(uint256 amount) external onlyDedicatedMsgSender {\r\n        count += amount;\r\n        lastExecuted = block.timestamp;\r\n\r\n        (uint256 fee, address feeToken) = _getFeeDetails();\r\n\r\n        _transfer(fee, feeToken);\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/userCreator/withTreasury/Counter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport {AutomateReady} from \"../../../AutomateReady.sol\";\r\n\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\ncontract Counter is AutomateReady {\r\n    uint256 public count;\r\n    uint256 public lastExecuted;\r\n\r\n    constructor(address payable _automate, address _taskCreator)\r\n        AutomateReady(_automate, _taskCreator)\r\n    {}\r\n\r\n    function increaseCount(uint256 amount) external onlyDedicatedMsgSender {\r\n        count += amount;\r\n        lastExecuted = block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/examples/userCreator/withTreasury/CounterResolver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICounter {\r\n    function increaseCount(uint256 amount) external;\r\n\r\n    function lastExecuted() external view returns (uint256);\r\n}\r\n\r\n// solhint-disable not-rely-on-time\r\ncontract CounterResolver {\r\n    ICounter public immutable counter;\r\n\r\n    constructor(ICounter _counter) {\r\n        counter = _counter;\r\n    }\r\n\r\n    function checker()\r\n        external\r\n        view\r\n        returns (bool canExec, bytes memory execPayload)\r\n    {\r\n        uint256 lastExecuted = counter.lastExecuted();\r\n\r\n        canExec = (block.timestamp - lastExecuted) > 180;\r\n\r\n        execPayload = abi.encodeCall(ICounter.increaseCount, (1));\r\n    }\r\n}\r\n"
    },
    "contracts/integrations/Types.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nenum Module {\r\n    RESOLVER,\r\n    DEPRECATED_TIME,\r\n    PROXY,\r\n    SINGLE_EXEC,\r\n    WEB3_FUNCTION,\r\n    TRIGGER\r\n}\r\n\r\nenum TriggerType {\r\n    TIME,\r\n    CRON,\r\n    EVENT,\r\n    BLOCK\r\n}\r\n\r\nstruct ModuleData {\r\n    Module[] modules;\r\n    bytes[] args;\r\n}\r\n\r\ninterface IAutomate {\r\n    function createTask(\r\n        address execAddress,\r\n        bytes calldata execDataOrSelector,\r\n        ModuleData calldata moduleData,\r\n        address feeToken\r\n    ) external returns (bytes32 taskId);\r\n\r\n    function cancelTask(bytes32 taskId) external;\r\n\r\n    function getFeeDetails() external view returns (uint256, address);\r\n\r\n    function gelato() external view returns (address payable);\r\n\r\n    function taskModuleAddresses(Module) external view returns (address);\r\n}\r\n\r\ninterface IProxyModule {\r\n    function opsProxyFactory() external view returns (address);\r\n}\r\n\r\ninterface IOpsProxyFactory {\r\n    function getProxyOf(address account) external view returns (address, bool);\r\n}\r\n\r\ninterface IGelato1Balance {\r\n    function depositNative(address _sponsor) external payable;\r\n\r\n    function depositToken(\r\n        address _sponsor,\r\n        address _token,\r\n        uint256 _amount\r\n    ) external;\r\n}\r\n\r\ninterface IGelato {\r\n    function feeCollector() external view returns (address);\r\n}\r\n"
    },
    "contracts/interfaces/IAutomate.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport {LibDataTypes} from \"../libraries/LibDataTypes.sol\";\r\nimport {IGelato1Balance} from \"./IGelato1Balance.sol\";\r\n\r\n// solhint-disable max-line-length\r\ninterface IAutomate is IGelato1Balance {\r\n    /**\r\n     * @notice Initiates a task with conditions which Gelato will monitor and execute when conditions are met.\r\n     *\r\n     * @param execAddress Address of contract that should be called by Gelato.\r\n     * @param execData Execution data to be called with / function selector if execution data is yet to be determined.\r\n     * @param moduleData Conditional modules that will be used. {See LibDataTypes-ModuleData}\r\n     * @param feeToken Address of token to be used as payment. Use address(0) if Gelato 1Balance is being used, 0xeeeeee... for ETH or native tokens.\r\n     *\r\n     * @return taskId Unique hash of the task created.\r\n     */\r\n    function createTask(\r\n        address execAddress,\r\n        bytes calldata execData,\r\n        LibDataTypes.ModuleData calldata moduleData,\r\n        address feeToken\r\n    ) external returns (bytes32 taskId);\r\n\r\n    /**\r\n     * @notice Terminates a task that was created and Gelato can no longer execute it.\r\n     *\r\n     * @param taskId Unique hash of the task that is being cancelled. {See LibTaskId-getTaskId}\r\n     */\r\n    function cancelTask(bytes32 taskId) external;\r\n\r\n    /**\r\n     * @notice Execution API called by Gelato, using Sync Fee as fee payment method\r\n     *\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that should be called by Gelato.\r\n     * @param execData Execution data to be called with / function selector if execution data is yet to be determined.\r\n     * @param moduleData Conditional modules that will be used. {See LibDataTypes-ModuleData}\r\n     * @param txFee Fee paid to Gelato for execution, transfered to Gelato.feeCollector().\r\n     * @param feeToken Token used to pay for the execution. ETH = 0xeeeeee...\r\n     * @param revertOnFailure To revert or not if call to execAddress fails. (Used for off-chain simulations)\r\n     */\r\n    function exec(\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes memory execData,\r\n        LibDataTypes.ModuleData calldata moduleData,\r\n        uint256 txFee,\r\n        address feeToken,\r\n        bool revertOnFailure\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Execution API called by Gelato, using Gelato 1Balance as fee payment method.\r\n     *\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that should be called by Gelato.\r\n     * @param execData Execution data to be called with / function selector if execution data is yet to be determined.\r\n     * @param moduleData Conditional modules that will be used. {See LibDataTypes-ModuleData}\r\n     * @param oneBalanceParam Parameters required for fee payment with Gelato 1Balance.\r\n     * @param revertOnFailure To revert or not if call to execAddress fails. (Used for off-chain simulations)\r\n     */\r\n    function exec1Balance(\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes memory execData,\r\n        LibDataTypes.ModuleData calldata moduleData,\r\n        Gelato1BalanceParam calldata oneBalanceParam,\r\n        bool revertOnFailure\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Sets the address of task modules. Only callable by proxy admin.\r\n     *\r\n     * @param modules List of modules to be set\r\n     * @param moduleAddresses List of addresses for respective modules.\r\n     */\r\n    function setModule(\r\n        LibDataTypes.Module[] calldata modules,\r\n        address[] calldata moduleAddresses\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Helper function to query fee and feeToken to be used for payment. (For executions which pays itself)\r\n     *\r\n     * @return uint256 Fee amount to be paid.\r\n     * @return address Token to be paid. (Determined and passed by taskCreator during createTask)\r\n     */\r\n    function getFeeDetails() external view returns (uint256, address);\r\n\r\n    /**\r\n     * @notice Helper func to query all open tasks by a task creator.\r\n     *\r\n     * @param taskCreator Address of task creator to query.\r\n     *\r\n     * @return bytes32[] List of taskIds created.\r\n     */\r\n    function getTaskIdsByUser(address taskCreator)\r\n        external\r\n        view\r\n        returns (bytes32[] memory);\r\n\r\n    /**\r\n     * @notice Helper function to compute task id with module arguments\r\n     *\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that will be called by Gelato.\r\n     * @param execSelector Signature of the function which will be called by Gelato.\r\n     * @param moduleData  Conditional modules that will be used. {See LibDataTypes-ModuleData}\r\n     * @param feeToken Address of token to be used as payment. Use address(0) if Gelato 1Balance is being used, 0xeeeeee... for ETH or native tokens.\r\n     */\r\n    function getTaskId(\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes4 execSelector,\r\n        LibDataTypes.ModuleData memory moduleData,\r\n        address feeToken\r\n    ) external pure returns (bytes32 taskId);\r\n}\r\n"
    },
    "contracts/interfaces/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Extended {\r\n    function decimals() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n"
    },
    "contracts/interfaces/IGelato1Balance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IGelato1Balance {\r\n    struct Gelato1BalanceParam {\r\n        address sponsor;\r\n        address feeToken;\r\n        uint256 oneBalanceChainId;\r\n        uint256 nativeToFeeTokenXRateNumerator;\r\n        uint256 nativeToFeeTokenXRateDenominator;\r\n        bytes32 correlationId;\r\n    }\r\n\r\n    event LogUseGelato1Balance(\r\n        address indexed sponsor,\r\n        address indexed target,\r\n        address indexed feeToken,\r\n        uint256 oneBalanceChainId,\r\n        uint256 nativeToFeeTokenXRateNumerator,\r\n        uint256 nativeToFeeTokenXRateDenominator,\r\n        bytes32 correlationId\r\n    );\r\n}\r\n"
    },
    "contracts/interfaces/IOpsProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\ninterface IOpsProxy {\r\n    /**\r\n     * @notice Emitted when proxy calls a contract successfully in `executeCall`\r\n     *\r\n     * @param target Address of contract that is called\r\n     * @param data Data used in the call.\r\n     * @param value Native token value used in the call.\r\n     * @param returnData Data returned by the call.\r\n     */\r\n    event ExecuteCall(\r\n        address indexed target,\r\n        bytes data,\r\n        uint256 value,\r\n        bytes returnData\r\n    );\r\n\r\n    /**\r\n     * @notice Multicall to different contracts with different datas.\r\n     *\r\n     * @param targets Addresses of contracts to be called.\r\n     * @param datas Datas for each contract call.\r\n     * @param values Native token value for each contract call.\r\n     */\r\n    function batchExecuteCall(\r\n        address[] calldata targets,\r\n        bytes[] calldata datas,\r\n        uint256[] calldata values\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Call to a single contract.\r\n     *\r\n     * @param target Address of contracts to be called.\r\n     * @param data Data for contract call.\r\n     * @param value Native token value for contract call.\r\n     */\r\n    function executeCall(\r\n        address target,\r\n        bytes calldata data,\r\n        uint256 value\r\n    ) external payable;\r\n\r\n    /**\r\n     * @return address Ops smart contract address\r\n     */\r\n    function ops() external view returns (address);\r\n\r\n    /**\r\n     * @return address Owner of the proxy\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @return uint256 version of OpsProxy.\r\n     */\r\n    function version() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IOpsProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\ninterface IOpsProxyFactory {\r\n    /**\r\n     * @notice Emitted when an OpsProxy is deployed.\r\n     *\r\n     * @param deployer Address which initiated the deployment\r\n     * @param owner The address which the proxy is for.\r\n     * @param proxy Address of deployed proxy.\r\n     */\r\n    event DeployProxy(\r\n        address indexed deployer,\r\n        address indexed owner,\r\n        address indexed proxy\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when OpsProxy implementation to be deployed is changed.\r\n     *\r\n     * @param oldImplementation Previous OpsProxy implementation.\r\n     * @param newImplementation Current OpsProxy implementation.\r\n     */\r\n    event SetImplementation(\r\n        address indexed oldImplementation,\r\n        address indexed newImplementation\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when OpsProxy implementation is added or removed from whitelist.\r\n     *\r\n     * @param implementation OpsProxy implementation.\r\n     * @param whitelisted Added or removed from whitelist.\r\n     */\r\n    event UpdateWhitelistedImplementation(\r\n        address indexed implementation,\r\n        bool indexed whitelisted\r\n    );\r\n\r\n    /**\r\n     * @notice Deploys OpsProxy for the msg.sender.\r\n     *\r\n     * @return proxy Address of deployed proxy.\r\n     */\r\n    function deploy() external returns (address payable proxy);\r\n\r\n    /**\r\n     * @notice Deploys OpsProxy for another address.\r\n     *\r\n     * @param owner Address to deploy the proxy for.\r\n     *\r\n     * @return proxy Address of deployed proxy.\r\n     */\r\n    function deployFor(address owner) external returns (address payable proxy);\r\n\r\n    /**\r\n     * @notice Sets the OpsProxy implementation that will be deployed by OpsProxyFactory.\r\n     *\r\n     * @param newImplementation New implementation to be set.\r\n     */\r\n    function setImplementation(address newImplementation) external;\r\n\r\n    /**\r\n     * @notice Add or remove OpsProxy implementation from the whitelist.\r\n     *\r\n     * @param implementation OpsProxy implementation.\r\n     * @param whitelist Added or removed from whitelist.\r\n     */\r\n    function updateWhitelistedImplementations(\r\n        address implementation,\r\n        bool whitelist\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Determines the OpsProxy address when it is not deployed.\r\n     *\r\n     * @param account Address to determine the proxy address for.\r\n     */\r\n    function determineProxyAddress(address account)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * @return address Proxy address owned by account.\r\n     * @return bool Whether if proxy is deployed\r\n     */\r\n    function getProxyOf(address account) external view returns (address, bool);\r\n\r\n    /**\r\n     * @return address Owner of deployed proxy.\r\n     */\r\n    function ownerOf(address proxy) external view returns (address);\r\n\r\n    /**\r\n     * @return bool Whether if implementation is whitelisted.\r\n     */\r\n    function whitelistedImplementations(address implementation)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice Standard interface that should be used when creating a resolver.\r\n *\r\n * NOTE `checker` can be non view as well as it will be\r\n * called with static call off chain\r\n */\r\ninterface IResolver {\r\n    function checker()\r\n        external\r\n        view\r\n        returns (bool canExec, bytes memory execPayload);\r\n}\r\n"
    },
    "contracts/interfaces/ITaskModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\n// solhint-disable max-line-length\r\ninterface ITaskModule {\r\n    /**\r\n     * @notice Called before generating taskId.\r\n     * @dev Modules can override execAddress or taskCreator. {See ProxyModule-preCreateTask}\r\n     *\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that should be called.\r\n     *\r\n     * @return address Overriden or original taskCreator.\r\n     * @return address Overriden or original execAddress.\r\n     */\r\n    function preCreateTask(address taskCreator, address execAddress)\r\n        external\r\n        returns (address, address);\r\n\r\n    /**\r\n     * @notice Initiates task module whenever `createTask` is being called.\r\n     *\r\n     * @param taskId Unique hash of the task created.\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that should be called.\r\n     * @param execData Execution data to be called with / function selector if execution data is yet to be determined.\r\n     * @param initModuleArg Encoded arguments for module if any.\r\n     */\r\n    function onCreateTask(\r\n        bytes32 taskId,\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes calldata execData,\r\n        bytes calldata initModuleArg\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Called before taskId is removed from _createdTasks[].\r\n     * @dev Modules can override taskCreator.\r\n     *\r\n     * @param taskId Unique hash of the task created.\r\n     * @param taskCreator The address which created the task.\r\n     *\r\n     * @return address Overriden or original taskCreator.\r\n     */\r\n    function preCancelTask(bytes32 taskId, address taskCreator)\r\n        external\r\n        returns (address);\r\n\r\n    /**\r\n     * @notice Called during `exec` and before execAddress is called.\r\n     *\r\n     * @param taskId Unique hash of the task created.\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that should be called.\r\n     * @param execData Execution data to be called with / function selector if execution data is yet to be determined.\r\n     *\r\n     * @return address Overriden or original execution address.\r\n     * @return bytes Overriden or original execution data.\r\n     */\r\n    function preExecCall(\r\n        bytes32 taskId,\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes calldata execData\r\n    ) external returns (address, bytes memory);\r\n\r\n    /**\r\n     * @notice Called during `exec` and after execAddress is called.\r\n     *\r\n     * @param taskId Unique hash of the task created.\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that should be called.\r\n     * @param execData Execution data to be called with / function selector if execution data is yet to be determined.\r\n     */\r\n    function postExecCall(\r\n        bytes32 taskId,\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes calldata execData\r\n    ) external;\r\n}\r\n"
    },
    "contracts/libraries/LibDataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\n// solhint-disable max-line-length\r\nlibrary LibDataTypes {\r\n    /**\r\n     * @notice Whitelisted modules that are available for users to customise conditions and specifications of their tasks.\r\n     *\r\n     * @param RESOLVER Use dynamic condition & input data for execution. {See ResolverModule.sol}\r\n     * @param DEPRECATED_TIME deprecated\r\n     * @param PROXY Creates a dedicated caller (msg.sender) to be used when executing the task. {See ProxyModule.sol}\r\n     * @param SINGLE_EXEC Task is cancelled after one execution. {See SingleExecModule.sol}\r\n     * @param WEB3_FUNCTION Use off-chain condition & input data for execution. {See Web3FunctionModule.sol}\r\n     * @param TRIGGER Repeated execution of task ata a specified timing and interval or cron. {See TriggerModule.sol}\r\n     */\r\n    enum Module {\r\n        RESOLVER,\r\n        DEPRECATED_TIME, // @deprecated\r\n        PROXY,\r\n        SINGLE_EXEC,\r\n        WEB3_FUNCTION,\r\n        TRIGGER\r\n    }\r\n\r\n    /**\r\n     * @notice Struct to contain modules and their relative arguments that are used for task creation.\r\n     *\r\n     * @param modules List of selected modules.\r\n     * @param args Arguments of modules if any. Pass \"0x\" for modules which does not require args {See encodeModuleArg}\r\n     */\r\n    struct ModuleData {\r\n        Module[] modules;\r\n        bytes[] args;\r\n    }\r\n\r\n    /**\r\n     * @notice Struct for time module.\r\n     *\r\n     * @param nextExec Time when the next execution should occur.\r\n     * @param interval Time interval between each execution.\r\n     */\r\n    struct Time {\r\n        uint128 nextExec;\r\n        uint128 interval;\r\n    }\r\n\r\n    /**\r\n     * @notice Types of trigger\r\n     *\r\n     * @param TIME Time triggered tasks, starting at a specific time and triggered intervally\r\n     * @param CRON Cron triggered tasks, triggered according to the cron conditions\r\n     */\r\n    enum TriggerType {\r\n        TIME,\r\n        CRON,\r\n        EVENT,\r\n        BLOCK\r\n    }\r\n\r\n    /**\r\n     * @notice Struct for trigger module\r\n     *\r\n     * @param triggerType Type of the trigger\r\n     * @param triggerConfig Trigger configuration that shuold be parsed according to triggerType\r\n     */\r\n    struct TriggerModuleData {\r\n        TriggerType triggerType;\r\n        bytes triggerConfig;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\nimport {LibDataTypes} from \"./LibDataTypes.sol\";\r\n\r\nlibrary LibEvents {\r\n    /**\r\n     * @notice Emitted when `createTask` is called.\r\n     *\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that is called by Gelato.\r\n     * @param execDataOrSelector Execution data / function selector.\r\n     * @param moduleData Conditional modules used. {See LibDataTypes-ModuleData}\r\n     * @param feeToken Token used to pay for the execution. ETH = 0xeeeeee...\r\n     * @param taskId Unique hash of the task. {See LibTaskId-getTaskId}\r\n     */\r\n    event TaskCreated(\r\n        address indexed taskCreator,\r\n        address indexed execAddress,\r\n        bytes execDataOrSelector,\r\n        LibDataTypes.ModuleData moduleData,\r\n        address feeToken,\r\n        bytes32 indexed taskId\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when `cancelTask` is called.\r\n     *\r\n     * @param taskId Unique hash of the task. {See LibTaskId-getTaskId}\r\n     * @param taskCreator The address which owned the task.\r\n     */\r\n    event TaskCancelled(bytes32 taskId, address taskCreator);\r\n\r\n    /**\r\n     * @notice Emitted when `exec` is called.\r\n     *\r\n     * @param txFee Fee paid to Gelato for execution\r\n     * @param feeToken Token used to pay for the execution. ETH = 0xeeeeee...\r\n     * @param execAddress Address of contract that will be called by Gelato.\r\n     * @param execData Execution data / function selector.\r\n     * @param taskId Unique hash of the task. {See LibTaskId-getTaskId}\r\n     * @param callSuccess Status of the call to execAddress.\r\n     */\r\n    event ExecSuccess(\r\n        uint256 indexed txFee,\r\n        address indexed feeToken,\r\n        address indexed execAddress,\r\n        bytes execData,\r\n        bytes32 taskId,\r\n        bool callSuccess\r\n    );\r\n}\r\n"
    },
    "contracts/libraries/LibTaskId.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport {LibDataTypes} from \"./LibDataTypes.sol\";\r\n\r\n/**\r\n * @notice Library to compute taskId of tasks.\r\n */\r\n// solhint-disable max-line-length\r\nlibrary LibTaskId {\r\n    /**\r\n     * @notice Returns taskId of taskCreator.\r\n     *\r\n     * @param taskCreator The address which created the task.\r\n     * @param execAddress Address of contract that will be called by Gelato.\r\n     * @param execSelector Signature of the function which will be called by Gelato.\r\n     * @param moduleData  Conditional modules that will be used. {See LibDataTypes-ModuleData}\r\n     * @param feeToken Address of token to be used as payment. Use address(0) if Gelato 1Balance is being used, 0xeeeeee... for ETH or native tokens.\r\n     */\r\n    function getTaskId(\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes4 execSelector,\r\n        LibDataTypes.ModuleData memory moduleData,\r\n        address feeToken\r\n    ) internal pure returns (bytes32 taskId) {\r\n        taskId = keccak256(\r\n            abi.encode(\r\n                taskCreator,\r\n                execAddress,\r\n                execSelector,\r\n                moduleData,\r\n                feeToken\r\n            )\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibTaskModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\nimport {_call, _delegateCall} from \"../functions/FExec.sol\";\r\nimport {LibDataTypes} from \"./LibDataTypes.sol\";\r\nimport {LibTaskModuleConfig} from \"./LibTaskModuleConfig.sol\";\r\nimport {ITaskModule} from \"../interfaces/ITaskModule.sol\";\r\n\r\n// solhint-disable function-max-lines\r\n/// @notice Library to call task modules on task creation and execution.\r\nlibrary LibTaskModule {\r\n    using LibTaskModuleConfig for LibDataTypes.Module;\r\n\r\n    /**\r\n     * @notice Delegate calls task modules before generating taskId.\r\n     *\r\n     * @param _execAddress Address of contract that will be called by Gelato.\r\n     * @param _taskCreator The address which created the task.\r\n     * @param taskModuleAddresses The storage reference to the mapping of modules to their address.\r\n     */\r\n    function preCreateTask(\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        mapping(LibDataTypes.Module => address) storage taskModuleAddresses\r\n    ) internal returns (address, address) {\r\n        uint256 length = uint256(type(LibDataTypes.Module).max) + 1;\r\n\r\n        for (uint256 i; i < length; i++) {\r\n            LibDataTypes.Module module = LibDataTypes.Module(i);\r\n            if (!module.requirePreCreate()) continue;\r\n\r\n            address moduleAddress = taskModuleAddresses[module];\r\n            _moduleInitialised(moduleAddress);\r\n\r\n            bytes memory delegatecallData = abi.encodeWithSelector(\r\n                ITaskModule.preCreateTask.selector,\r\n                _taskCreator,\r\n                _execAddress\r\n            );\r\n\r\n            (, bytes memory returnData) = _delegateCall(\r\n                moduleAddress,\r\n                delegatecallData,\r\n                \"Automate.preCreateTask: \"\r\n            );\r\n\r\n            (_taskCreator, _execAddress) = abi.decode(\r\n                returnData,\r\n                (address, address)\r\n            );\r\n        }\r\n\r\n        return (_taskCreator, _execAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate calls task modules on create task to initialise them.\r\n     *\r\n     * @param _taskId Unique hash of the task. {See LibTaskId-getTaskId}\r\n     * @param _taskCreator The address which created the task.\r\n     * @param _execAddress Address of contract that will be called by Gelato.\r\n     * @param _execData Execution data to be called with / function selector.\r\n     * @param _moduleData Modules that will be used for the task. {See LibDataTypes-ModuleData}\r\n     * @param taskModuleAddresses The storage reference to the mapping of modules to their address.\r\n     */\r\n    function onCreateTask(\r\n        bytes32 _taskId,\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes memory _execData,\r\n        LibDataTypes.ModuleData memory _moduleData,\r\n        mapping(LibDataTypes.Module => address) storage taskModuleAddresses\r\n    ) internal {\r\n        uint256 length = _moduleData.modules.length;\r\n\r\n        _validModules(_moduleData.modules);\r\n\r\n        for (uint256 i; i < length; i++) {\r\n            LibDataTypes.Module module = _moduleData.modules[i];\r\n            if (!module.requireOnCreate()) continue;\r\n\r\n            address moduleAddress = taskModuleAddresses[module];\r\n            _moduleInitialised(moduleAddress);\r\n\r\n            bytes memory delegatecallData = abi.encodeWithSelector(\r\n                ITaskModule.onCreateTask.selector,\r\n                _taskId,\r\n                _taskCreator,\r\n                _execAddress,\r\n                _execData,\r\n                _moduleData.args[i]\r\n            );\r\n\r\n            _delegateCall(\r\n                moduleAddress,\r\n                delegatecallData,\r\n                \"Automate.onCreateTask: \"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate calls task modules before removing task.\r\n     *\r\n     * @param _taskId Unique hash of the task. {See LibTaskId-getTaskId}\r\n     * @param _taskCreator The address which created the task.\r\n     * @param taskModuleAddresses The storage reference to the mapping of modules to their address.\r\n     */\r\n    function preCancelTask(\r\n        bytes32 _taskId,\r\n        address _taskCreator,\r\n        mapping(LibDataTypes.Module => address) storage taskModuleAddresses\r\n    ) internal returns (address) {\r\n        uint256 length = uint256(type(LibDataTypes.Module).max);\r\n\r\n        for (uint256 i; i <= length; i++) {\r\n            LibDataTypes.Module module = LibDataTypes.Module(i);\r\n\r\n            if (!module.requirePreCancel()) continue;\r\n\r\n            address moduleAddress = taskModuleAddresses[module];\r\n            _moduleInitialised(moduleAddress);\r\n\r\n            bytes memory delegatecallData = abi.encodeWithSelector(\r\n                ITaskModule.preCancelTask.selector,\r\n                _taskId,\r\n                _taskCreator\r\n            );\r\n\r\n            (, bytes memory returnData) = _delegateCall(\r\n                moduleAddress,\r\n                delegatecallData,\r\n                \"Automate.preCancelTask: \"\r\n            );\r\n\r\n            (_taskCreator) = abi.decode(returnData, (address));\r\n        }\r\n\r\n        return _taskCreator;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate calls task modules on exec.\r\n     *\r\n     * @param _taskId Unique hash of the task. {See LibTaskId-getTaskId}\r\n     * @param _taskCreator Address which created the task.\r\n     * @param _execAddress Address of contract that will be called by Gelato.\r\n     * @param _execData Execution data to be called with / function selector.\r\n     * @param _modules Modules that is used for the task. {See LibDataTypes-Module}\r\n     * @param _revertOnFailure To revert or not if call to execAddress fails.\r\n     * @param taskModuleAddresses The storage reference to the mapping of modules to their address.\r\n     */\r\n    function onExecTask(\r\n        bytes32 _taskId,\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes memory _execData,\r\n        LibDataTypes.Module[] memory _modules,\r\n        bool _revertOnFailure,\r\n        mapping(LibDataTypes.Module => address) storage taskModuleAddresses\r\n    ) internal returns (bool callSuccess) {\r\n        address[] memory moduleAddresses = _getModuleAddresses(\r\n            _modules,\r\n            taskModuleAddresses\r\n        );\r\n\r\n        (_execAddress, _execData) = _preExecCall(\r\n            _taskId,\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execData,\r\n            _modules,\r\n            moduleAddresses\r\n        );\r\n\r\n        (callSuccess, ) = _call(\r\n            _execAddress,\r\n            abi.encodePacked(_execData, _taskCreator),\r\n            0,\r\n            _revertOnFailure,\r\n            \"Automate.exec: \"\r\n        );\r\n\r\n        _postExecCall(\r\n            _taskId,\r\n            _taskCreator,\r\n            _execAddress,\r\n            _execData,\r\n            _modules,\r\n            moduleAddresses\r\n        );\r\n    }\r\n\r\n    function _preExecCall(\r\n        bytes32 _taskId,\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes memory _execData,\r\n        LibDataTypes.Module[] memory _modules,\r\n        address[] memory _moduleAddresses\r\n    ) private returns (address, bytes memory) {\r\n        uint256 length = _modules.length;\r\n\r\n        for (uint256 i; i < length; i++) {\r\n            if (!_modules[i].requirePreExec()) continue;\r\n\r\n            bytes memory delegatecallData = abi.encodeWithSelector(\r\n                ITaskModule.preExecCall.selector,\r\n                _taskId,\r\n                _taskCreator,\r\n                _execAddress,\r\n                _execData\r\n            );\r\n\r\n            (, bytes memory returnData) = _delegateCall(\r\n                _moduleAddresses[i],\r\n                delegatecallData,\r\n                \"Automate.preExecCall: \"\r\n            );\r\n\r\n            (_execAddress, _execData) = abi.decode(\r\n                returnData,\r\n                (address, bytes)\r\n            );\r\n        }\r\n        return (_execAddress, _execData);\r\n    }\r\n\r\n    function _postExecCall(\r\n        bytes32 _taskId,\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes memory _execData,\r\n        LibDataTypes.Module[] memory _modules,\r\n        address[] memory _moduleAddresses\r\n    ) private {\r\n        uint256 length = _moduleAddresses.length;\r\n\r\n        for (uint256 i; i < length; i++) {\r\n            if (!_modules[i].requirePostExec()) continue;\r\n\r\n            bytes memory delegatecallData = abi.encodeWithSelector(\r\n                ITaskModule.postExecCall.selector,\r\n                _taskId,\r\n                _taskCreator,\r\n                _execAddress,\r\n                _execData\r\n            );\r\n\r\n            _delegateCall(\r\n                _moduleAddresses[i],\r\n                delegatecallData,\r\n                \"Automate.postExecCall: \"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _getModuleAddresses(\r\n        LibDataTypes.Module[] memory _modules,\r\n        mapping(LibDataTypes.Module => address) storage taskModuleAddresses\r\n    ) private view returns (address[] memory) {\r\n        uint256 length = _modules.length;\r\n        address[] memory moduleAddresses = new address[](length);\r\n\r\n        for (uint256 i; i < length; i++) {\r\n            moduleAddresses[i] = taskModuleAddresses[_modules[i]];\r\n        }\r\n\r\n        return moduleAddresses;\r\n    }\r\n\r\n    function _moduleInitialised(address _moduleAddress) private pure {\r\n        require(\r\n            _moduleAddress != address(0),\r\n            \"Automate._moduleInitialised: Not init\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev\r\n     * - No duplicate modules\r\n     * - No deprecated TIME\r\n     * - No RESOLVER && WEB3_FUNCTION\r\n     * - PROXY is required\r\n     */\r\n    function _validModules(LibDataTypes.Module[] memory _modules) private pure {\r\n        uint256 length = _modules.length;\r\n\r\n        uint256 existsLength = uint256(type(LibDataTypes.Module).max) + 1;\r\n        bool[] memory exists = new bool[](existsLength);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (i > 0) {\r\n                require(\r\n                    _modules[i] > _modules[i - 1],\r\n                    \"Automate._validModules: Asc only\"\r\n                );\r\n            }\r\n\r\n            exists[uint256(_modules[i])] = true;\r\n        }\r\n\r\n        require(\r\n            !exists[uint256(LibDataTypes.Module.DEPRECATED_TIME)],\r\n            \"Automate._validModules: TIME is deprecated\"\r\n        );\r\n\r\n        require(\r\n            !(exists[uint256(LibDataTypes.Module.RESOLVER)] &&\r\n                exists[uint256(LibDataTypes.Module.WEB3_FUNCTION)]),\r\n            \"Automate._validModules: Only RESOLVER or WEB3_FUNCTION\"\r\n        );\r\n\r\n        require(\r\n            exists[uint256(LibDataTypes.Module.PROXY)],\r\n            \"Automate._validModules: PROXY is required\"\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibTaskModuleConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\nimport {LibDataTypes} from \"./LibDataTypes.sol\";\r\n\r\n/**\r\n * @notice Library to determine wether to call task modules to reduce unnecessary calls.\r\n */\r\nlibrary LibTaskModuleConfig {\r\n    function requirePreCreate(LibDataTypes.Module _module)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (_module == LibDataTypes.Module.PROXY) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function requirePreCancel(LibDataTypes.Module _module)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (_module == LibDataTypes.Module.PROXY) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function requireOnCreate(LibDataTypes.Module _module)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (_module == LibDataTypes.Module.PROXY) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function requirePreExec(LibDataTypes.Module _module)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (_module == LibDataTypes.Module.PROXY) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function requirePostExec(LibDataTypes.Module _module)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (_module == LibDataTypes.Module.SINGLE_EXEC) return true;\r\n\r\n        return false;\r\n    }\r\n}\r\n"
    },
    "contracts/opsProxy/OpsProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {Proxied} from \"../vendor/proxy/EIP173/Proxied.sol\";\r\nimport {_call} from \"../functions/FExec.sol\";\r\nimport {IOpsProxy} from \"../interfaces/IOpsProxy.sol\";\r\n\r\ncontract OpsProxy is Proxied, IOpsProxy {\r\n    // solhint-disable const-name-snakecase\r\n    uint256 public constant override version = 1;\r\n    address public immutable override ops;\r\n\r\n    modifier onlyAuth() {\r\n        address proxyOwner = owner();\r\n        if (msg.sender != proxyOwner) {\r\n            require(msg.sender == ops, \"OpsProxy: Not authorised\");\r\n            require(\r\n                _getTaskCreator() == proxyOwner,\r\n                \"OpsProxy: Only tasks created by owner\"\r\n            );\r\n        } // else msg.sender == proxyOwner\r\n        _;\r\n    }\r\n\r\n    // solhint-disable no-empty-blocks\r\n    constructor(address _ops) {\r\n        ops = _ops;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    ///@inheritdoc IOpsProxy\r\n    function batchExecuteCall(\r\n        address[] calldata _targets,\r\n        bytes[] calldata _datas,\r\n        uint256[] calldata _values\r\n    ) external payable override onlyAuth {\r\n        uint256 length = _targets.length;\r\n        require(\r\n            length == _datas.length && length == _values.length,\r\n            \"OpsProxy: Length mismatch\"\r\n        );\r\n\r\n        for (uint256 i; i < length; i++)\r\n            _executeCall(_targets[i], _datas[i], _values[i]);\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxy\r\n    function executeCall(\r\n        address _target,\r\n        bytes calldata _data,\r\n        uint256 _value\r\n    ) external payable override onlyAuth {\r\n        _executeCall(_target, _data, _value);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _proxyAdmin();\r\n    }\r\n\r\n    function _executeCall(\r\n        address _target,\r\n        bytes calldata _data,\r\n        uint256 _value\r\n    ) private {\r\n        (, bytes memory returnData) = _call(\r\n            _target,\r\n            _data,\r\n            _value,\r\n            true,\r\n            \"OpsProxy.executeCall: \"\r\n        );\r\n\r\n        emit ExecuteCall(_target, _data, _value, returnData);\r\n    }\r\n\r\n    function _getTaskCreator() private pure returns (address taskCreator) {\r\n        assembly {\r\n            taskCreator := shr(96, calldataload(sub(calldatasize(), 20)))\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/opsProxy/OpsProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {\r\n    Initializable\r\n} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport {EIP173OpsProxy} from \"../vendor/proxy/EIP173/EIP173OpsProxy.sol\";\r\nimport {Proxied} from \"../vendor/proxy/EIP173/Proxied.sol\";\r\nimport {IOpsProxyFactory} from \"../interfaces/IOpsProxyFactory.sol\";\r\n\r\n// solhint-disable max-states-count\r\ncontract OpsProxyFactory is Initializable, Proxied, IOpsProxyFactory {\r\n    address public immutable ops;\r\n    address public implementation;\r\n    mapping(address => bool) public override whitelistedImplementations;\r\n\r\n    ///@dev track proxy of user\r\n    mapping(address => address) internal _proxyOf;\r\n\r\n    ///@dev track owner of proxy\r\n    mapping(address => address) internal _ownerOf;\r\n\r\n    modifier onlyOneProxy(address _account) {\r\n        require(_proxyOf[_account] == address(0), \"OpsProxyFactory: One proxy\");\r\n        _;\r\n    }\r\n\r\n    modifier notProxy(address _account) {\r\n        require(_ownerOf[_account] == address(0), \"OpsProxyFactory: No proxy\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _ops) {\r\n        ops = _ops;\r\n    }\r\n\r\n    function initialize(address _implementation) external initializer {\r\n        implementation = _implementation;\r\n        whitelistedImplementations[_implementation] = true;\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function deploy() external override returns (address payable proxy) {\r\n        proxy = deployFor(msg.sender);\r\n    }\r\n\r\n    function setImplementation(address _newImplementation)\r\n        external\r\n        onlyProxyAdmin\r\n    {\r\n        address oldImplementation = implementation;\r\n        require(\r\n            oldImplementation != _newImplementation &&\r\n                whitelistedImplementations[_newImplementation],\r\n            \"OpsProxyFactory: Invalid implementation\"\r\n        );\r\n\r\n        implementation = _newImplementation;\r\n\r\n        emit SetImplementation(oldImplementation, _newImplementation);\r\n    }\r\n\r\n    function updateWhitelistedImplementations(\r\n        address _implementation,\r\n        bool _whitelist\r\n    ) external onlyProxyAdmin {\r\n        whitelistedImplementations[_implementation] = _whitelist;\r\n\r\n        emit UpdateWhitelistedImplementation(_implementation, _whitelist);\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function getProxyOf(address _account)\r\n        external\r\n        view\r\n        override\r\n        returns (address, bool)\r\n    {\r\n        address proxyAddress = _proxyOf[_account];\r\n\r\n        if (proxyAddress != address(0)) return (proxyAddress, true);\r\n\r\n        proxyAddress = determineProxyAddress(_account);\r\n        return (proxyAddress, false);\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function ownerOf(address _proxy) external view override returns (address) {\r\n        return _ownerOf[_proxy];\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function deployFor(address owner)\r\n        public\r\n        override\r\n        onlyOneProxy(owner)\r\n        notProxy(owner)\r\n        returns (address payable proxy)\r\n    {\r\n        proxy = _deploy(bytes32(0), _getBytecode(owner));\r\n\r\n        _proxyOf[owner] = proxy;\r\n        _ownerOf[proxy] = owner;\r\n\r\n        emit DeployProxy(msg.sender, owner, address(proxy));\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function determineProxyAddress(address _account)\r\n        public\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        address proxyAddress = _proxyOf[_account];\r\n        if (proxyAddress != address(0)) return proxyAddress;\r\n\r\n        bytes memory bytecode = _getBytecode(_account);\r\n\r\n        bytes32 codeHash = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0xff),\r\n                address(this),\r\n                bytes32(0),\r\n                keccak256(bytecode)\r\n            )\r\n        );\r\n\r\n        return address(uint160(uint256(codeHash)));\r\n    }\r\n\r\n    function _deploy(bytes32 _salt, bytes memory _bytecode)\r\n        internal\r\n        returns (address payable proxy)\r\n    {\r\n        assembly {\r\n            let endowment := 0\r\n            let bytecodeStart := add(_bytecode, 0x20)\r\n            let bytecodeLength := mload(_bytecode)\r\n            proxy := create2(endowment, bytecodeStart, bytecodeLength, _salt)\r\n        }\r\n    }\r\n\r\n    function _getBytecode(address _owner) internal view returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                type(EIP173OpsProxy).creationCode,\r\n                abi.encode(address(this), implementation, _owner, bytes(\"\"))\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/opsProxy/OpsProxyFactoryZkSync.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {\r\n    Initializable\r\n} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport {EIP173OpsProxy} from \"../vendor/proxy/EIP173/EIP173OpsProxy.sol\";\r\nimport {Proxied} from \"../vendor/proxy/EIP173/Proxied.sol\";\r\nimport {IOpsProxyFactory} from \"../interfaces/IOpsProxyFactory.sol\";\r\n\r\n// solhint-disable max-states-count\r\ncontract OpsProxyFactoryZkSync is Initializable, Proxied, IOpsProxyFactory {\r\n    address public immutable ops;\r\n    bytes32 public immutable eip173OpsProxyByteCodeHash;\r\n\r\n    address public implementation;\r\n    mapping(address => bool) public override whitelistedImplementations;\r\n\r\n    ///@dev track proxy of user\r\n    mapping(address => address) internal _proxyOf;\r\n\r\n    ///@dev track owner of proxy\r\n    mapping(address => address) internal _ownerOf;\r\n\r\n    modifier onlyOneProxy(address _account) {\r\n        require(_proxyOf[_account] == address(0), \"OpsProxyFactory: One proxy\");\r\n        _;\r\n    }\r\n\r\n    modifier notProxy(address _account) {\r\n        require(_ownerOf[_account] == address(0), \"OpsProxyFactory: No proxy\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _ops, bytes32 _eip173OpsProxyByteCodeHash) {\r\n        ops = _ops;\r\n        eip173OpsProxyByteCodeHash = _eip173OpsProxyByteCodeHash;\r\n    }\r\n\r\n    function initialize(address _implementation) external initializer {\r\n        implementation = _implementation;\r\n        whitelistedImplementations[_implementation] = true;\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function deploy() external override returns (address payable proxy) {\r\n        proxy = deployFor(msg.sender);\r\n    }\r\n\r\n    function setImplementation(address _newImplementation)\r\n        external\r\n        onlyProxyAdmin\r\n    {\r\n        address oldImplementation = implementation;\r\n        require(\r\n            oldImplementation != _newImplementation &&\r\n                whitelistedImplementations[_newImplementation],\r\n            \"OpsProxyFactory: Invalid implementation\"\r\n        );\r\n\r\n        implementation = _newImplementation;\r\n\r\n        emit SetImplementation(oldImplementation, _newImplementation);\r\n    }\r\n\r\n    function updateWhitelistedImplementations(\r\n        address _implementation,\r\n        bool _whitelist\r\n    ) external onlyProxyAdmin {\r\n        whitelistedImplementations[_implementation] = _whitelist;\r\n\r\n        emit UpdateWhitelistedImplementation(_implementation, _whitelist);\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function getProxyOf(address _account)\r\n        external\r\n        view\r\n        override\r\n        returns (address, bool)\r\n    {\r\n        address proxyAddress = _proxyOf[_account];\r\n\r\n        if (proxyAddress != address(0)) return (proxyAddress, true);\r\n\r\n        proxyAddress = determineProxyAddress(_account);\r\n        return (proxyAddress, false);\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function ownerOf(address _proxy) external view override returns (address) {\r\n        return _ownerOf[_proxy];\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function deployFor(address owner)\r\n        public\r\n        override\r\n        onlyOneProxy(owner)\r\n        notProxy(owner)\r\n        returns (address payable proxy)\r\n    {\r\n        proxy = _deploy(bytes32(0), _getBytecode(owner));\r\n\r\n        _proxyOf[owner] = proxy;\r\n        _ownerOf[proxy] = owner;\r\n\r\n        emit DeployProxy(msg.sender, owner, address(proxy));\r\n    }\r\n\r\n    ///@inheritdoc IOpsProxyFactory\r\n    function determineProxyAddress(address _account)\r\n        public\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        bytes32 constructorInputHash = keccak256(\r\n            _encodeConstructorInput(_account)\r\n        );\r\n\r\n        bytes32 create2Hash = keccak256(\r\n            bytes.concat(\r\n                keccak256(\"zksyncCreate2\"),\r\n                bytes32(uint256(uint160(address(this)))),\r\n                bytes32(0),\r\n                eip173OpsProxyByteCodeHash,\r\n                constructorInputHash\r\n            )\r\n        );\r\n\r\n        return address(uint160(uint256(create2Hash)));\r\n    }\r\n\r\n    function _deploy(bytes32 _salt, bytes memory _bytecode)\r\n        internal\r\n        returns (address payable proxy)\r\n    {\r\n        assembly {\r\n            let endowment := 0\r\n            let bytecodeStart := add(_bytecode, 0x20)\r\n            let bytecodeLength := mload(_bytecode)\r\n            proxy := create2(endowment, bytecodeStart, bytecodeLength, _salt)\r\n        }\r\n    }\r\n\r\n    function _getBytecode(address _owner) internal view returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                type(EIP173OpsProxy).creationCode,\r\n                _encodeConstructorInput(_owner)\r\n            );\r\n    }\r\n\r\n    function _encodeConstructorInput(address _account)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return abi.encode(address(this), implementation, _account, bytes(\"\"));\r\n    }\r\n}\r\n"
    },
    "contracts/taskModules/ProxyModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {TaskModuleBase} from \"./TaskModuleBase.sol\";\r\nimport {IOpsProxy} from \"../interfaces/IOpsProxy.sol\";\r\nimport {IOpsProxyFactory} from \"../interfaces/IOpsProxyFactory.sol\";\r\n\r\ncontract ProxyModule is TaskModuleBase {\r\n    IOpsProxyFactory public immutable opsProxyFactory;\r\n\r\n    constructor(IOpsProxyFactory _opsProxyFactory) {\r\n        opsProxyFactory = _opsProxyFactory;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc TaskModuleBase\r\n     */\r\n    function onCreateTask(\r\n        bytes32,\r\n        address _taskCreator,\r\n        address,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external override {\r\n        _deployIfNoProxy(_taskCreator);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc TaskModuleBase\r\n     * @dev _taskCreator cannot create task to other user's proxy\r\n     */\r\n    function preCreateTask(address _taskCreator, address _execAddress)\r\n        external\r\n        view\r\n        override\r\n        returns (address, address)\r\n    {\r\n        address ownerOfExecAddress = opsProxyFactory.ownerOf(_execAddress);\r\n\r\n        if (ownerOfExecAddress != address(0)) {\r\n            // creating task to proxy\r\n            require(\r\n                _taskCreator == ownerOfExecAddress ||\r\n                    _taskCreator == _execAddress,\r\n                \"ProxyModule: Only owner of proxy\"\r\n            );\r\n\r\n            return (ownerOfExecAddress, _execAddress);\r\n        } else {\r\n            address ownerOfTaskCreator = opsProxyFactory.ownerOf(_taskCreator);\r\n\r\n            if (ownerOfTaskCreator != address(0)) {\r\n                // creating task to non proxy, with proxy\r\n                // give task ownership to proxy owner\r\n                return (ownerOfTaskCreator, _execAddress);\r\n            }\r\n\r\n            // creating task to non proxy, without proxy\r\n            return (_taskCreator, _execAddress);\r\n        }\r\n    }\r\n\r\n    function preCancelTask(bytes32, address _taskCreator)\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        address ownerOfTaskCreator = opsProxyFactory.ownerOf(_taskCreator);\r\n\r\n        if (ownerOfTaskCreator != address(0)) {\r\n            return ownerOfTaskCreator;\r\n        }\r\n\r\n        return _taskCreator;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc TaskModuleBase\r\n     * @dev _execData is encoded with proxy's `executeCall` function\r\n     * unless _execAddress is OpsProxy which assumes that _execData is encoded\r\n     * with `executeCall` or `batchExecuteCall`.\r\n     */\r\n    function preExecCall(\r\n        bytes32,\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes calldata _execData\r\n    ) external view override returns (address, bytes memory execData) {\r\n        (address proxy, ) = opsProxyFactory.getProxyOf(_taskCreator);\r\n\r\n        execData = _execAddress == proxy\r\n            ? _execData\r\n            : _encodeWithOpsProxy(_execAddress, _execData);\r\n\r\n        _execAddress = proxy;\r\n\r\n        return (_execAddress, execData);\r\n    }\r\n\r\n    function _deployIfNoProxy(address _taskCreator) private {\r\n        bool isTaskCreatorProxy = opsProxyFactory.ownerOf(_taskCreator) !=\r\n            address(0);\r\n\r\n        if (!isTaskCreatorProxy) {\r\n            (, bool deployed) = opsProxyFactory.getProxyOf(_taskCreator);\r\n            if (!deployed) opsProxyFactory.deployFor(_taskCreator);\r\n        }\r\n    }\r\n\r\n    function _encodeWithOpsProxy(address _execAddress, bytes calldata _execData)\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            abi.encodeWithSelector(\r\n                IOpsProxy.executeCall.selector,\r\n                _execAddress,\r\n                _execData,\r\n                0\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/taskModules/ResolverModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {TaskModuleBase} from \"./TaskModuleBase.sol\";\r\n\r\ncontract ResolverModule is TaskModuleBase {\r\n    /**\r\n     * @notice Helper function to encode arguments for ResolverModule.\r\n     *\r\n     * @param _resolverAddress Address of resolver.\r\n     * @param _resolverData Data passed to resolver.\r\n     */\r\n    function encodeModuleArg(\r\n        address _resolverAddress,\r\n        bytes calldata _resolverData\r\n    ) external pure returns (bytes memory) {\r\n        return abi.encode(_resolverAddress, _resolverData);\r\n    }\r\n}\r\n"
    },
    "contracts/taskModules/SingleExecModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {\r\n    EnumerableSet\r\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport {TaskModuleBase} from \"./TaskModuleBase.sol\";\r\nimport {LibEvents} from \"../libraries/LibEvents.sol\";\r\n\r\ncontract SingleExecModule is TaskModuleBase {\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n\r\n    /// @inheritdoc TaskModuleBase\r\n    function postExecCall(\r\n        bytes32 _taskId,\r\n        address _taskCreator,\r\n        address,\r\n        bytes calldata\r\n    ) external override {\r\n        _createdTasks[_taskCreator].remove(_taskId);\r\n\r\n        emit LibEvents.TaskCancelled(_taskId, _taskCreator);\r\n    }\r\n}\r\n"
    },
    "contracts/taskModules/TaskModuleBase.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {AutomateStorage} from \"../AutomateStorage.sol\";\r\nimport {ITaskModule} from \"../interfaces/ITaskModule.sol\";\r\n\r\n// solhint-disable no-empty-blocks\r\nabstract contract TaskModuleBase is AutomateStorage, ITaskModule {\r\n    ///@inheritdoc ITaskModule\r\n    function preCreateTask(address _taskCreator, address _execAddress)\r\n        external\r\n        virtual\r\n        override\r\n        returns (address, address)\r\n    {\r\n        return (_taskCreator, _execAddress);\r\n    }\r\n\r\n    ///@inheritdoc ITaskModule\r\n    function onCreateTask(\r\n        bytes32,\r\n        address,\r\n        address,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) external virtual override {}\r\n\r\n    ///@inheritdoc ITaskModule\r\n    function preCancelTask(bytes32, address _taskCreator)\r\n        external\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        return _taskCreator;\r\n    }\r\n\r\n    ///@inheritdoc ITaskModule\r\n    function preExecCall(\r\n        bytes32,\r\n        address,\r\n        address _execAddress,\r\n        bytes calldata _execData\r\n    ) external virtual override returns (address, bytes memory) {\r\n        return (_execAddress, _execData);\r\n    }\r\n\r\n    ///@inheritdoc ITaskModule\r\n    function postExecCall(\r\n        bytes32 taskId,\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes calldata execData\r\n    ) external virtual override {}\r\n}\r\n"
    },
    "contracts/taskModules/TriggerModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {TaskModuleBase} from \"./TaskModuleBase.sol\";\r\nimport {LibDataTypes} from \"../libraries/LibDataTypes.sol\";\r\n\r\n// solhint-disable not-rely-on-time\r\ncontract TriggerModule is TaskModuleBase {\r\n    /**\r\n     * @notice Helper function to encode arguments for TriggerModule for Timer.\r\n     *\r\n     * @param _start Time when the first execution should occur.\r\n     * @param _interval Time interval between each execution.\r\n     */\r\n    function encodeTimeTriggerModuleArg(uint128 _start, uint128 _interval)\r\n        external\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory triggerConfig = abi.encode(_start, _interval);\r\n\r\n        return abi.encode(LibDataTypes.TriggerType.TIME, triggerConfig);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to encode arguments for TriggerModule for Cron.\r\n     *\r\n     * @param _expression Cron expression\r\n     */\r\n    function encodeCronTriggerModuleArg(string calldata _expression)\r\n        external\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory triggerConfig = abi.encode(_expression);\r\n\r\n        return abi.encode(LibDataTypes.TriggerType.CRON, triggerConfig);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to encode arguments for TriggerModule for Event.\r\n     *\r\n     * @param _address Address to listen to for events.\r\n     * @param _topics Set of topics to filter at each topic position.\r\n     * @param _blockConfirmations Number of blocks to wait for before triggering.\r\n     */\r\n    function encodeEventTriggerModuleArg(\r\n        address _address,\r\n        bytes32[][] memory _topics,\r\n        uint256 _blockConfirmations\r\n    ) external pure returns (bytes memory) {\r\n        bytes memory triggerConfig = abi.encode(\r\n            _address,\r\n            _topics,\r\n            _blockConfirmations\r\n        );\r\n\r\n        return abi.encode(LibDataTypes.TriggerType.EVENT, triggerConfig);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to encode arguments for TriggerModule for Block.\r\n     */\r\n    function encodeBlockTriggerModuleArg()\r\n        external\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return abi.encode(LibDataTypes.TriggerType.BLOCK);\r\n    }\r\n}\r\n"
    },
    "contracts/taskModules/Web3FunctionModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {TaskModuleBase} from \"./TaskModuleBase.sol\";\r\nimport {LibDataTypes} from \"../libraries/LibDataTypes.sol\";\r\nimport {_call} from \"../functions/FExec.sol\";\r\n\r\ncontract Web3FunctionModule is TaskModuleBase {\r\n    /**\r\n     * @notice Helper function to encode arguments for Web3FunctionModule.\r\n     *\r\n     * @param _web3FunctionHash IPFS hash of web3 function.\r\n     * @param _web3FunctionArgsHex Arguments to be passed into web3 function in hex.\r\n     */\r\n    function encodeModuleArg(\r\n        string memory _web3FunctionHash,\r\n        bytes calldata _web3FunctionArgsHex\r\n    ) external pure returns (bytes memory) {\r\n        return abi.encode(_web3FunctionHash, _web3FunctionArgsHex);\r\n    }\r\n}\r\n"
    },
    "contracts/vendor/gelato/GelatoBytes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nlibrary GelatoBytes {\r\n    function calldataSliceSelector(bytes calldata _bytes)\r\n        internal\r\n        pure\r\n        returns (bytes4 selector)\r\n    {\r\n        selector =\r\n            _bytes[0] |\r\n            (bytes4(_bytes[1]) >> 8) |\r\n            (bytes4(_bytes[2]) >> 16) |\r\n            (bytes4(_bytes[3]) >> 24);\r\n    }\r\n\r\n    function memorySliceSelector(bytes memory _bytes)\r\n        internal\r\n        pure\r\n        returns (bytes4 selector)\r\n    {\r\n        selector =\r\n            _bytes[0] |\r\n            (bytes4(_bytes[1]) >> 8) |\r\n            (bytes4(_bytes[2]) >> 16) |\r\n            (bytes4(_bytes[3]) >> 24);\r\n    }\r\n\r\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\r\n        internal\r\n        pure\r\n    {\r\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\r\n        if (_bytes.length % 32 == 4) {\r\n            bytes4 selector;\r\n            assembly {\r\n                selector := mload(add(0x20, _bytes))\r\n            }\r\n            if (selector == 0x08c379a0) {\r\n                // Function selector for Error(string)\r\n                assembly {\r\n                    _bytes := add(_bytes, 68)\r\n                }\r\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\r\n            } else {\r\n                revert(\r\n                    string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"))\r\n                );\r\n            }\r\n        } else {\r\n            revert(\r\n                string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"))\r\n            );\r\n        }\r\n    }\r\n\r\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\r\n        if (_bytes.length % 32 == 4) {\r\n            bytes4 selector;\r\n            assembly {\r\n                selector := mload(add(0x20, _bytes))\r\n            }\r\n            if (selector == 0x08c379a0) {\r\n                // Function selector for Error(string)\r\n                assembly {\r\n                    _bytes := add(_bytes, 68)\r\n                }\r\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\r\n            } else {\r\n                return\r\n                    string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"));\r\n            }\r\n        } else {\r\n            return\r\n                string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/vendor/gelato/Gelatofied.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {\r\n    SafeERC20,\r\n    IERC20\r\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {_transfer, ETH} from \"../../functions/FUtils.sol\";\r\n\r\nabstract contract Gelatofied {\r\n    address payable public immutable gelato;\r\n\r\n    modifier gelatofy(uint256 _amount, address _paymentToken) {\r\n        require(msg.sender == gelato, \"Gelatofied: Only gelato\");\r\n        _;\r\n        _transfer(gelato, _paymentToken, _amount);\r\n    }\r\n\r\n    modifier onlyGelato() {\r\n        require(msg.sender == gelato, \"Gelatofied: Only gelato\");\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _gelato) {\r\n        gelato = _gelato;\r\n    }\r\n}\r\n"
    },
    "contracts/vendor/gelato/OpsReady.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\nimport {\r\n    SafeERC20,\r\n    IERC20\r\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ninterface IAutomate {\r\n    function gelato() external view returns (address payable);\r\n}\r\n\r\nabstract contract AutomateReady {\r\n    address public immutable automate;\r\n    address payable public immutable gelato;\r\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    modifier onlyAutomate() {\r\n        require(msg.sender == automate, \"AutomateReady: onlyAutomate\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _automate) {\r\n        automate = _automate;\r\n        gelato = IAutomate(_automate).gelato();\r\n    }\r\n\r\n    function _transfer(uint256 _amount, address _paymentToken) internal {\r\n        if (_paymentToken == ETH) {\r\n            (bool success, ) = gelato.call{value: _amount}(\"\");\r\n            require(success, \"_transfer: ETH transfer failed\");\r\n        } else {\r\n            SafeERC20.safeTransfer(IERC20(_paymentToken), gelato, _amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/vendor/proxy/EIP173/EIP173OpsProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\nimport \"./Proxy.sol\";\r\nimport {IOpsProxyFactory} from \"../../../interfaces/IOpsProxyFactory.sol\";\r\n\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 id) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @notice Proxy implementing EIP173 for ownership management.\r\n * @notice This is used for OpsProxy.\r\n *\r\n * @dev 1. custom receive can be set in implementation.\r\n * @dev 2. transferProxyAdmin removed.\r\n * @dev 3. implementation can only be set to those whitelisted on OpsProxyFactory.\r\n */\r\ncontract EIP173OpsProxy is Proxy {\r\n    // ////////////////////////// STATES ///////////////////////////////////////////////////////////////////////\r\n    IOpsProxyFactory public immutable opsProxyFactory;\r\n\r\n    // ////////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////\r\n\r\n    event ProxyAdminTransferred(\r\n        address indexed previousAdmin,\r\n        address indexed newAdmin\r\n    );\r\n\r\n    // /////////////////////// MODIFIERS //////////////////////////////////////////////////////////////////////\r\n    modifier onlyWhitelistedImplementation(address _implementation) {\r\n        require(\r\n            opsProxyFactory.whitelistedImplementations(_implementation),\r\n            \"Implementation not whitelisted\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // /////////////////////// FALLBACKS //////////////////////////////////////////////////////////////////////\r\n    receive() external payable override {\r\n        _fallback();\r\n    }\r\n\r\n    // /////////////////////// CONSTRUCTOR //////////////////////////////////////////////////////////////////////\r\n\r\n    constructor(\r\n        address _opsProxyFactory,\r\n        address implementationAddress,\r\n        address adminAddress,\r\n        bytes memory data\r\n    ) payable {\r\n        opsProxyFactory = IOpsProxyFactory(_opsProxyFactory);\r\n        _setImplementation(implementationAddress, data);\r\n        _setProxyAdmin(adminAddress);\r\n    }\r\n\r\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\r\n\r\n    function proxyAdmin() external view returns (address) {\r\n        return _proxyAdmin();\r\n    }\r\n\r\n    function supportsInterface(bytes4 id) external view returns (bool) {\r\n        if (id == 0x01ffc9a7 || id == 0x7f5828d0) {\r\n            return true;\r\n        }\r\n        if (id == 0xFFFFFFFF) {\r\n            return false;\r\n        }\r\n\r\n        ERC165 implementation;\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            implementation := sload(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\r\n            )\r\n        }\r\n\r\n        // Technically this is not standard compliant as ERC-165 require 30,000 gas which that call cannot ensure\r\n        // because it is itself inside `supportsInterface` that might only get 30,000 gas.\r\n        // In practise this is unlikely to be an issue.\r\n        try implementation.supportsInterface(id) returns (bool support) {\r\n            return support;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function upgradeTo(address newImplementation)\r\n        external\r\n        onlyProxyAdmin\r\n        onlyWhitelistedImplementation(newImplementation)\r\n    {\r\n        _setImplementation(newImplementation, \"\");\r\n    }\r\n\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n        external\r\n        payable\r\n        onlyProxyAdmin\r\n        onlyWhitelistedImplementation(newImplementation)\r\n    {\r\n        _setImplementation(newImplementation, data);\r\n    }\r\n\r\n    // /////////////////////// MODIFIERS ////////////////////////////////////////////////////////////////////////\r\n\r\n    modifier onlyProxyAdmin() {\r\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\r\n\r\n    function _proxyAdmin() internal view returns (address adminAddress) {\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            adminAddress := sload(\r\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\r\n            )\r\n        }\r\n    }\r\n\r\n    function _setProxyAdmin(address newAdmin) internal {\r\n        address previousAdmin = _proxyAdmin();\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            sstore(\r\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\r\n                newAdmin\r\n            )\r\n        }\r\n        emit ProxyAdminTransferred(previousAdmin, newAdmin);\r\n    }\r\n}\r\n"
    },
    "contracts/vendor/proxy/EIP173/EIP173Proxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\nimport \"./Proxy.sol\";\r\n\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 id) external view returns (bool);\r\n}\r\n\r\n///@notice Proxy implementing EIP173 for ownership management\r\ncontract EIP173Proxy is Proxy {\r\n    // ////////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////\r\n\r\n    event ProxyAdminTransferred(\r\n        address indexed previousAdmin,\r\n        address indexed newAdmin\r\n    );\r\n\r\n    // /////////////////////// CONSTRUCTOR //////////////////////////////////////////////////////////////////////\r\n\r\n    constructor(\r\n        address implementationAddress,\r\n        address adminAddress,\r\n        bytes memory data\r\n    ) payable {\r\n        _setImplementation(implementationAddress, data);\r\n        _setProxyAdmin(adminAddress);\r\n    }\r\n\r\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\r\n\r\n    function proxyAdmin() external view returns (address) {\r\n        return _proxyAdmin();\r\n    }\r\n\r\n    function supportsInterface(bytes4 id) external view returns (bool) {\r\n        if (id == 0x01ffc9a7 || id == 0x7f5828d0) {\r\n            return true;\r\n        }\r\n        if (id == 0xFFFFFFFF) {\r\n            return false;\r\n        }\r\n\r\n        ERC165 implementation;\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            implementation := sload(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\r\n            )\r\n        }\r\n\r\n        // Technically this is not standard compliant as ERC-165 require 30,000 gas which that call cannot ensure\r\n        // because it is itself inside `supportsInterface` that might only get 30,000 gas.\r\n        // In practise this is unlikely to be an issue.\r\n        try implementation.supportsInterface(id) returns (bool support) {\r\n            return support;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferProxyAdmin(address newAdmin) external onlyProxyAdmin {\r\n        _setProxyAdmin(newAdmin);\r\n    }\r\n\r\n    function upgradeTo(address newImplementation) external onlyProxyAdmin {\r\n        _setImplementation(newImplementation, \"\");\r\n    }\r\n\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n        external\r\n        payable\r\n        onlyProxyAdmin\r\n    {\r\n        _setImplementation(newImplementation, data);\r\n    }\r\n\r\n    // /////////////////////// MODIFIERS ////////////////////////////////////////////////////////////////////////\r\n\r\n    modifier onlyProxyAdmin() {\r\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\r\n\r\n    function _proxyAdmin() internal view returns (address adminAddress) {\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            adminAddress := sload(\r\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\r\n            )\r\n        }\r\n    }\r\n\r\n    function _setProxyAdmin(address newAdmin) internal {\r\n        address previousAdmin = _proxyAdmin();\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            sstore(\r\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\r\n                newAdmin\r\n            )\r\n        }\r\n        emit ProxyAdminTransferred(previousAdmin, newAdmin);\r\n    }\r\n}\r\n"
    },
    "contracts/vendor/proxy/EIP173/Proxied.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\nabstract contract Proxied {\r\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\r\n    /// It also allows these functions to be called inside a contructor\r\n    /// even if the contract is meant to be used without proxy\r\n    modifier proxied() {\r\n        address proxyAdminAddress = _proxyAdmin();\r\n        // With hardhat-deploy proxies\r\n        // the proxyAdminAddress is zero only for the implementation contract\r\n        // if the implementation contract want to be used as a standalone/immutable contract\r\n        // it simply has to execute the `proxied` function\r\n        // This ensure the proxyAdminAddress is never zero post deployment\r\n        // And allow you to keep the same code for both proxied contract and immutable contract\r\n        if (proxyAdminAddress == address(0)) {\r\n            // ensure can not be called twice when used outside of proxy : no admin\r\n            // solhint-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                sstore(\r\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\r\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n                )\r\n            }\r\n        } else {\r\n            require(msg.sender == proxyAdminAddress);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyProxyAdmin() {\r\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function _proxyAdmin() internal view returns (address adminAddress) {\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            adminAddress := sload(\r\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\r\n            )\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/vendor/proxy/EIP173/Proxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\n// EIP-1967\r\nabstract contract Proxy {\r\n    // /////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////////\r\n\r\n    event ProxyImplementationUpdated(\r\n        address indexed previousImplementation,\r\n        address indexed newImplementation\r\n    );\r\n\r\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\r\n\r\n    // prettier-ignore\r\n    receive() external payable virtual {\r\n        revert(\"ETHER_REJECTED\"); // explicit reject by default\r\n    }\r\n\r\n    fallback() external payable {\r\n        _fallback();\r\n    }\r\n\r\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\r\n\r\n    function _fallback() internal {\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let implementationAddress := sload(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\r\n            )\r\n            calldatacopy(0x0, 0x0, calldatasize())\r\n            let success := delegatecall(\r\n                gas(),\r\n                implementationAddress,\r\n                0x0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            let retSz := returndatasize()\r\n            returndatacopy(0, 0, retSz)\r\n            switch success\r\n            case 0 {\r\n                revert(0, retSz)\r\n            }\r\n            default {\r\n                return(0, retSz)\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setImplementation(address newImplementation, bytes memory data)\r\n        internal\r\n    {\r\n        address previousImplementation;\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            previousImplementation := sload(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\r\n            )\r\n        }\r\n\r\n        // solhint-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            sstore(\r\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\r\n                newImplementation\r\n            )\r\n        }\r\n\r\n        emit ProxyImplementationUpdated(\r\n            previousImplementation,\r\n            newImplementation\r\n        );\r\n\r\n        if (data.length > 0) {\r\n            (bool success, ) = newImplementation.delegatecall(data);\r\n            if (!success) {\r\n                assembly {\r\n                    // This assembly ensure the revert contains the exact string data\r\n                    let returnDataSize := returndatasize()\r\n                    returndatacopy(0, 0, returnDataSize)\r\n                    revert(0, returnDataSize)\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}